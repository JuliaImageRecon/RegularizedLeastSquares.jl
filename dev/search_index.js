var documenterSearchIndex = {"docs":
[{"location":"API/regularization.html#API","page":"Regularization Terms","title":"API","text":"","category":"section"},{"location":"API/regularization.html","page":"Regularization Terms","title":"Regularization Terms","text":"This page contains documentation of the public API of the RegularizedLeastSquares. In the Julia REPL one can access this documentation by entering the help mode with ?","category":"page"},{"location":"API/regularization.html#General","page":"Regularization Terms","title":"General","text":"","category":"section"},{"location":"API/regularization.html","page":"Regularization Terms","title":"Regularization Terms","text":"RegularizedLeastSquares.prox!(::AbstractParameterizedRegularization, ::AbstractArray)\nRegularizedLeastSquares.norm(::AbstractParameterizedRegularization, ::AbstractArray)\nRegularizedLeastSquares.λ(::AbstractParameterizedRegularization)\nRegularizedLeastSquares.prox!(::Type{<:AbstractParameterizedRegularization}, ::Any, ::Any)\nRegularizedLeastSquares.norm(::Type{<:AbstractParameterizedRegularization}, ::Any, ::Any)","category":"page"},{"location":"API/regularization.html#RegularizedLeastSquares.prox!-Tuple{AbstractParameterizedRegularization, AbstractArray}","page":"Regularization Terms","title":"RegularizedLeastSquares.prox!","text":"prox!(reg::AbstractParameterizedRegularization, x)\n\nperform the proximal mapping defined by reg on x. Uses the regularization parameter defined for reg.\n\n\n\n\n\n","category":"method"},{"location":"API/regularization.html#LinearAlgebra.norm-Tuple{AbstractParameterizedRegularization, AbstractArray}","page":"Regularization Terms","title":"LinearAlgebra.norm","text":"norm(reg::AbstractParameterizedRegularization, x)\n\nreturns the value of the reg regularization term on x. Uses the regularization parameter defined for reg.\n\n\n\n\n\n","category":"method"},{"location":"API/regularization.html#RegularizedLeastSquares.λ-Tuple{AbstractParameterizedRegularization}","page":"Regularization Terms","title":"RegularizedLeastSquares.λ","text":"λ(reg::AbstractParameterizedRegularization)\n\nreturn the regularization parameter λ of reg\n\n\n\n\n\n","category":"method"},{"location":"API/regularization.html#RegularizedLeastSquares.prox!-Tuple{Type{<:AbstractParameterizedRegularization}, Any, Any}","page":"Regularization Terms","title":"RegularizedLeastSquares.prox!","text":"prox!(regType::Type{<:AbstractParameterizedRegularization}, x, λ; kwargs...)\n\nconstruct a regularization term of type regType with given λ and kwargs and apply its prox! on x\n\n\n\n\n\n","category":"method"},{"location":"API/regularization.html#LinearAlgebra.norm-Tuple{Type{<:AbstractParameterizedRegularization}, Any, Any}","page":"Regularization Terms","title":"LinearAlgebra.norm","text":"norm(regType::Type{<:AbstractParameterizedRegularization}, x, λ; kwargs...)\n\nconstruct a regularization term of type regType with given λ and kwargs and apply its norm on x\n\n\n\n\n\n","category":"method"},{"location":"API/regularization.html#Parameterized-Regularization","page":"Regularization Terms","title":"Parameterized Regularization","text":"","category":"section"},{"location":"API/regularization.html","page":"Regularization Terms","title":"Regularization Terms","text":"RegularizedLeastSquares.L1Regularization\nRegularizedLeastSquares.L2Regularization\nRegularizedLeastSquares.L21Regularization\nRegularizedLeastSquares.LLRRegularization\nRegularizedLeastSquares.NuclearRegularization\nRegularizedLeastSquares.TVRegularization","category":"page"},{"location":"API/regularization.html#RegularizedLeastSquares.L1Regularization","page":"Regularization Terms","title":"RegularizedLeastSquares.L1Regularization","text":"L1Regularization\n\nRegularization term implementing the proximal map for the Lasso problem.\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.L2Regularization","page":"Regularization Terms","title":"RegularizedLeastSquares.L2Regularization","text":"L2Regularization\n\nRegularization term implementing the proximal map for Tikhonov regularization.\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.L21Regularization","page":"Regularization Terms","title":"RegularizedLeastSquares.L21Regularization","text":"L21Regularization\n\nRegularization term implementing the proximal map for group-soft-thresholding.\n\nArguments\n\nλ                  - regularization paramter\n\nKeywords\n\nslices=1           - number of elements per group\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.LLRRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.LLRRegularization","text":"LLRRegularization\n\nRegularization term implementing the proximal map for locally low rank (LLR) regularization using singular-value-thresholding.\n\nArguments\n\nλ                  - regularization paramter\n\nKeywords\n\nshape::Tuple{Int}=[]        - dimensions of the image\nblockSize::Tuple{Int}=[2;2] - size of patches to perform singular value thresholding on\nrandshift::Bool=true        - randomly shifts the patches to ensure translation invariance\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.NuclearRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.NuclearRegularization","text":"NuclearRegularization\n\nRegularization term implementing the proximal map for singular value soft-thresholding.\n\nArguments:\n\nλ           - regularization paramter\n\nKeywords\n\nsvtShape::NTuple  - size of the underlying matrix\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.TVRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.TVRegularization","text":"TVRegularization\n\nRegularization term implementing the proximal map for TV regularization. Calculated with the Condat algorithm if the TV is calculated only along one dimension and with the Fast Gradient Projection algorithm otherwise.\n\nReference for the Condat algorithm: https://lcondat.github.io/publis/Condat-fast_TV-SPL-2013.pdf\n\nReference for the FGP algorithm: A. Beck and T. Teboulle, \"Fast Gradient-Based Algorithms for Constrained Total Variation Image Denoising and Deblurring Problems\", IEEE Trans. Image Process. 18(11), 2009\n\nReference for the FGP algorithm: A. Beck and T. Teboulle, \"Fast Gradient-Based Algorithms for Constrained Total Variation Image Denoising and Deblurring Problems\", IEEE Trans. Image Process. 18(11), 2009\n\nArguments\n\nλ::T                    - regularization parameter\n\nKeywords\n\nshape::NTuple           - size of the underlying image\ndims                    - Dimension to perform the TV along. If Integer, the Condat algorithm is called, and the FDG algorithm otherwise.\niterationsTV=20         - number of FGP iterations\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#Projection-Regularization","page":"Regularization Terms","title":"Projection Regularization","text":"","category":"section"},{"location":"API/regularization.html","page":"Regularization Terms","title":"Regularization Terms","text":"RegularizedLeastSquares.PositiveRegularization\nRegularizedLeastSquares.RealRegularization","category":"page"},{"location":"API/regularization.html#RegularizedLeastSquares.PositiveRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.PositiveRegularization","text":"PositiveRegularization\n\nRegularization term implementing a projection onto positive and real numbers.\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.RealRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.RealRegularization","text":"RealRegularization\n\nRegularization term implementing a projection onto real numbers.\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#Nested-Regularization","page":"Regularization Terms","title":"Nested Regularization","text":"","category":"section"},{"location":"API/regularization.html","page":"Regularization Terms","title":"Regularization Terms","text":"RegularizedLeastSquares.innerreg(::AbstractNestedRegularization)\nRegularizedLeastSquares.sink(::AbstractNestedRegularization)\nRegularizedLeastSquares.sinktype(::AbstractNestedRegularization)","category":"page"},{"location":"API/regularization.html#RegularizedLeastSquares.innerreg-Tuple{AbstractNestedRegularization}","page":"Regularization Terms","title":"RegularizedLeastSquares.innerreg","text":"innerreg(reg::AbstractNestedRegularization)\n\nreturn the inner regularization term of reg. Nested regularization terms also implement the iteration interface.\n\n\n\n\n\n","category":"method"},{"location":"API/regularization.html#RegularizedLeastSquares.sink-Tuple{AbstractNestedRegularization}","page":"Regularization Terms","title":"RegularizedLeastSquares.sink","text":"sink(reg::AbstractNestedRegularization)\n\nreturn the innermost regularization term.\n\n\n\n\n\n","category":"method"},{"location":"API/regularization.html#RegularizedLeastSquares.sinktype-Tuple{AbstractNestedRegularization}","page":"Regularization Terms","title":"RegularizedLeastSquares.sinktype","text":"sinktype(reg::AbstractNestedRegularization)\n\nreturn the type of the innermost regularization term.\n\nSee also sink.\n\n\n\n\n\n","category":"method"},{"location":"API/regularization.html#Scaled-Regularization","page":"Regularization Terms","title":"Scaled Regularization","text":"","category":"section"},{"location":"API/regularization.html","page":"Regularization Terms","title":"Regularization Terms","text":"RegularizedLeastSquares.AbstractScaledRegularization\nRegularizedLeastSquares.scalefactor\nRegularizedLeastSquares.NormalizedRegularization\nRegularizedLeastSquares.NoNormalization\nRegularizedLeastSquares.MeasurementBasedNormalization\nRegularizedLeastSquares.SystemMatrixBasedNormalization\nRegularizedLeastSquares.FixedParameterRegularization","category":"page"},{"location":"API/regularization.html#RegularizedLeastSquares.AbstractScaledRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.AbstractScaledRegularization","text":"AbstractScaledRegularization\n\nNested regularization term that applies a factor to the regularization parameter λ of its inner term.\n\nSee also factor, λ, innerreg.\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.scalefactor","page":"Regularization Terms","title":"RegularizedLeastSquares.scalefactor","text":"scalefactor(reg::AbstractScaledRegularization)\n\nreturn the scaling factor for λ\n\n\n\n\n\n","category":"function"},{"location":"API/regularization.html#RegularizedLeastSquares.NormalizedRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.NormalizedRegularization","text":"NormalizedRegularization\n\nNested regularization term that scales λ according to normalization scheme. This term is commonly applied by a solver based on a given normalization keyword\n\n#See also NoNormalization, MeasurementBasedNormalization, SystemMatrixBasedNormalization.\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.NoNormalization","page":"Regularization Terms","title":"RegularizedLeastSquares.NoNormalization","text":"NoNormalization\n\nNo normalization to λ is applied.\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.MeasurementBasedNormalization","page":"Regularization Terms","title":"RegularizedLeastSquares.MeasurementBasedNormalization","text":"MeasurementBasedNormalization\n\nλ is normalized by the 1-norm of b divided by its length.\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.SystemMatrixBasedNormalization","page":"Regularization Terms","title":"RegularizedLeastSquares.SystemMatrixBasedNormalization","text":"SystemMatrixBasedNormalization\n\nλ is normalized by the energy of the system matrix rows.\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.FixedParameterRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.FixedParameterRegularization","text":"FixedParameterRegularization\n\nNested regularization term that discards any λ passed to it and instead uses λ from its inner regularization term. This can be used to selectively disallow normalization. \n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#Misc.-Nested-Regularization","page":"Regularization Terms","title":"Misc. Nested Regularization","text":"","category":"section"},{"location":"API/regularization.html","page":"Regularization Terms","title":"Regularization Terms","text":"RegularizedLeastSquares.MaskedRegularization\nRegularizedLeastSquares.TransformedRegularization\nRegularizedLeastSquares.ConstraintTransformedRegularization\nRegularizedLeastSquares.PlugAndPlayRegularization","category":"page"},{"location":"API/regularization.html#RegularizedLeastSquares.MaskedRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.MaskedRegularization","text":"MaskedRegularization\n\nNested regularization term that only applies prox! and norm to elements of x for which the mask is true.\n\nExamples\n\njulia> positive = PositiveRegularization();\n\njulia> masked = MaskedRegularization(reg, [true, false, true, false]);\n\njulia> prox!(masked, fill(-1, 4))\n4-element Vector{Float64}:\n  0.0\n -1.0\n  0.0\n -1.0\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.TransformedRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.TransformedRegularization","text":"TransformedRegularization(reg, trafo)\n\nNested regularization term that applies prox! or norm on z = trafo * x and returns (inplace) x = adjoint(trafo) * z.\n\nExample\n\njulia> core = L1Regularization(0.8)\nL1Regularization{Float64}(0.8)\n\njulia> wop = WaveletOp(Float32, shape = (32,32));\n\njulia> reg = TransformedRegularization(core, wop);\n\njulia> prox!(reg, randn(32*32)); # Apply soft-thresholding in Wavelet domain\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.ConstraintTransformedRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.ConstraintTransformedRegularization","text":"ConstraintTransformedRegularization\n\nNested regularization term that associates the nested regularization term with a transform.\n\nArguments\n\nreg - inner regularization term\ntrafo - transform associated with reg\n\n\n\n\n\n","category":"type"},{"location":"API/regularization.html#RegularizedLeastSquares.PlugAndPlayRegularization","page":"Regularization Terms","title":"RegularizedLeastSquares.PlugAndPlayRegularization","text":"    PlugAndPlayRegularization\n\nRegularization term implementing a given plug-and-play proximal mapping. The actual regularization term is indirectly defined by the learned proximal mapping and as such there is no norm implemented.\n\nArguments\n\nλ                  - regularization paramter\n\nKeywords\n\nmodel       - model applied to the image\nshape       - dimensions of the image\ninput_transform - transform of image before model\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"RegularizedLeastSquares.jl provides a variety of solvers, which are used in fields such as MPI and MRI. The following is a non-exhaustive list of the implemented solvers:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Kaczmarz algorithm (Kaczmarz)\nConjugate Gradients Normal Residual method (CGNR)\nFast Iterative Shrinkage Thresholding Algorithm (FISTA)\nAlternating Direction of Multipliers Method (ADMM)","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"The solvers are organized in a type-hierarchy and inherit from:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"abstract type AbstractLinearSolver","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"The type hierarchy is further differentiated into solver categories such as AbstractRowAtionSolver, AbstractPrimalDualSolver or AbstractProximalGradientSolver. A list of all available solvers can be returned by the linearSolverList function.","category":"page"},{"location":"solvers.html#Creating-a-Solver","page":"Solvers","title":"Creating a Solver","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"To create a solver, one can invoke the method createLinearSolver as in","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"solver = createLinearSolver(ADMM, A; reg=reg, kwargs...)","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Here A denotes the system matrix and reg are the Regularization terms to be used by the solver. All further solver parameters can be passed as keyword arguments and are solver specific. To make things more compact, it can be usefull to collect all parameters in a Dict{Symbol,Any}. In this way, the code snippet above can be written as","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"params=Dict{Symbol,Any}()\nparams[:reg] = ...\n...\n\nsolver = createLinearSolver(ADMM, A; params...)","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"This notation can be convenient when a large number of parameters are set manually.","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"It is possible to check if a given solver is applicable to the wanted arguments, as not all solvers are applicable to all system matrix and data (element) types or regularization terms combinations. This is achieved with the isapplicable function:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"isapplicable(Kaczmarz, A, x, [L21Regularization(0.4f0)])\nfalse","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"For a given set of arguments the list of applicable solvers can be retrieved with applicableSolverList.","category":"page"},{"location":"API/solvers.html#API","page":"Solvers","title":"API","text":"","category":"section"},{"location":"API/solvers.html","page":"Solvers","title":"Solvers","text":"This page contains documentation of the public API of the RegularizedLeastSquares. In the Julia REPL one can access this documentation by entering the help mode with ?","category":"page"},{"location":"API/solvers.html#General","page":"Solvers","title":"General","text":"","category":"section"},{"location":"API/solvers.html","page":"Solvers","title":"Solvers","text":"RegularizedLeastSquares.linearSolverList\nRegularizedLeastSquares.createLinearSolver\nRegularizedLeastSquares.solve(::AbstractLinearSolver, ::Any)\nRegularizedLeastSquares.SolverInfo\nRegularizedLeastSquares.applicableSolverList\nRegularizedLeastSquares.isapplicable","category":"page"},{"location":"API/solvers.html#RegularizedLeastSquares.linearSolverList","page":"Solvers","title":"RegularizedLeastSquares.linearSolverList","text":"Return a list of all available linear solvers\n\n\n\n\n\n","category":"function"},{"location":"API/solvers.html#RegularizedLeastSquares.createLinearSolver","page":"Solvers","title":"RegularizedLeastSquares.createLinearSolver","text":"createLinearSolver(solver::AbstractLinearSolver, A; log::Bool=false, kargs...)\n\nThis method creates a solver. The supported solvers are methods typically used for solving regularized linear systems. All solvers return an approximate solution to Ax = b.\n\nTODO: give a hint what solvers are available\n\n\n\n\n\n","category":"function"},{"location":"API/solvers.html#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}","page":"Solvers","title":"RegularizedLeastSquares.solve","text":"solve(solver::AbstractLinearSolver, b; solverInfo = nothing, kwargs...)\n\nsolves an inverse problem using solver. When solverInfo is passed to the function information about the iteration process is stored.\n\nSee also SolverInfo.\n\n\n\n\n\n","category":"method"},{"location":"API/solvers.html#RegularizedLeastSquares.SolverInfo","page":"Solvers","title":"RegularizedLeastSquares.SolverInfo","text":"The Solver Info type is used to obtain aditional information of linear solvers and their iteration process.\n\nFields\n\nconvMeas::Vector{Float64} - Vector with convergence parameters\nnrmse::Vector{Float64}    - NRMSD of the current iterate w.r.t some reference (if provided)\nx_ref::Vector{T}          - Reference for computing NRMSD of iterates\nx_iter::Vector{Vector{T}} - Vector for storing iterates\nstore_solutions::Bool     - specification whether iterates are to be stored\n\nthe content of convMeas is specific to each solver. It can be found in the documentation of the corresping solve-method.\n\n\n\n\n\n","category":"type"},{"location":"API/solvers.html#RegularizedLeastSquares.applicableSolverList","page":"Solvers","title":"RegularizedLeastSquares.applicableSolverList","text":"applicable(args...)\n\nlist all solvers that are applicable to the given arguments. Arguments are the same as for isapplicable without the solver type.\n\nSee also isapplicable, linearSolverList.\n\n\n\n\n\n","category":"function"},{"location":"API/solvers.html#RegularizedLeastSquares.isapplicable","page":"Solvers","title":"RegularizedLeastSquares.isapplicable","text":"isapplicable(solverType::Type{<:AbstractLinearSolver}, A, x, reg)\n\nreturn true if a solver of type solverType is applicable to system matrix A, data x and regularization terms reg. \n\n\n\n\n\n","category":"function"},{"location":"API/solvers.html#ADMM","page":"Solvers","title":"ADMM","text":"","category":"section"},{"location":"API/solvers.html","page":"Solvers","title":"Solvers","text":"RegularizedLeastSquares.ADMM\nRegularizedLeastSquares.solve(::ADMM, ::Any)","category":"page"},{"location":"API/solvers.html#RegularizedLeastSquares.ADMM","page":"Solvers","title":"RegularizedLeastSquares.ADMM","text":"ADMM(A, x; kwargs...)\n\ncreates an ADMM object for the system matrix A.\n\nArguments\n\nA                           - system matrix\nx                     - (optional) array with the same type and size as the solution\n\nKeywords\n\nreg          - regularization term vector\nnormalizeReg         - regularization normalization scheme\nprecon=Identity()        - preconditionner for the internal CG algorithm\nρ::Real=1.e-2          - penalty of the augmented lagrangian\nvary_ρ::Bool=:none      - vary rho to balance primal and dual feasibility\niterations::Int64=50      - max number of ADMM iterations\niterationsInner::Int64=10 - max number of internal CG iterations\nabsTol::Real=eps()     - abs tolerance for stopping criterion\nrelTol::Real=eps()     - rel tolerance for stopping criterion\ntolInner::Real=1.e-5   - rel tolerance for CG stopping criterion\n\nSee also createLinearSolver, solve.\n\n\n\n\n\n","category":"type"},{"location":"API/solvers.html#RegularizedLeastSquares.solve-Tuple{ADMM, Any}","page":"Solvers","title":"RegularizedLeastSquares.solve","text":"solve(solver::ADMM, b; kwargs...) where {matT,vecT}\n\nsolves an inverse problem using ADMM.\n\nArguments\n\nsolver::ADMM                  - the solver containing both system matrix and regularizer\nb::Vector                     - data vector\n\nKeywords\n\nA::matT=solver.A            - operator for the data-term of the problem\nstartVector::Vector{T}=T[]  - initial guess for the solution\nsolverInfo=nothing          - solverInfo for logging\n\nwhen a SolverInfo objects is passed, the primal residuals solver.rᵏ and the dual residual norm(solver.sᵏ) are stored in solverInfo.convMeas.\n\n\n\n\n\n","category":"method"},{"location":"API/solvers.html#CGNR","page":"Solvers","title":"CGNR","text":"","category":"section"},{"location":"API/solvers.html","page":"Solvers","title":"Solvers","text":"RegularizedLeastSquares.CGNR\nRegularizedLeastSquares.solve(::CGNR, ::Any)","category":"page"},{"location":"API/solvers.html#RegularizedLeastSquares.CGNR","page":"Solvers","title":"RegularizedLeastSquares.CGNR","text":"CGNR(A, x; kargs...)\n\ncreates an CGNR object for the system matrix A.\n\nArguments\n\nA                               - system matrix\nx::vecT                         - (optional) array with the same type and size as the solution\n\nKeywords\n\nreg   - regularization term vector\nnormalizeReg         - regularization normalization scheme\nweights::vecT=eltype(A)[] - weights for the data term\nAᴴA=A'*A              - specialized normal operator, default is A'*A\niterations::Int64=10      - number of iterations\nrelTol::Float64=eps()         - rel tolerance for stopping criterion\n\nSee also createLinearSolver, solve.\n\n\n\n\n\n","category":"type"},{"location":"API/solvers.html#RegularizedLeastSquares.solve-Tuple{CGNR, Any}","page":"Solvers","title":"RegularizedLeastSquares.solve","text":"solve(solver::CGNR, u; kwargs...) where vecT\n\nsolves Tikhonov-regularized inverse problem using CGNR.\n\nArguments\n\n`solver::CGNR                         - the solver containing both system matrix and regularizer\nu::vecT                             - data vector\n\nKeywords\n\nstartVector::vecT=similar(u,0)    - initial guess for the solution\nsolverInfo=nothing                - solverInfo for logging\n\nwhen a SolverInfo objects is passed, the residuals solver.zl are stored in solverInfo.convMeas.\n\n\n\n\n\n","category":"method"},{"location":"API/solvers.html#Kaczmarz","page":"Solvers","title":"Kaczmarz","text":"","category":"section"},{"location":"API/solvers.html","page":"Solvers","title":"Solvers","text":"RegularizedLeastSquares.Kaczmarz\nRegularizedLeastSquares.solve(::Kaczmarz, ::Vector{Any})","category":"page"},{"location":"API/solvers.html#RegularizedLeastSquares.Kaczmarz","page":"Solvers","title":"RegularizedLeastSquares.Kaczmarz","text":"Kaczmarz(S, b; kwargs...)\n\ncreates a Kaczmarz object\n\nArguments\n\nS                                             - system matrix\nb=nothing                                     - measurement\n\nKeywords\n\nreg          - regularization term vector\nnormalizeReg         - regularization normalization scheme\nweights::Vector{R}=ones(Float64,size(S,1)) - weights for the data term\nenforceReal::Bool=false                     - constrain the solution to be real\nenforcePositive::Bool=false                 - constrain the solution to have positive real part\nrandomized::Bool=false                  - randomize Kacmarz algorithm\nsubMatrixFraction::Float64=0.1              - fraction of rows used in randomized Kaczmarz algorithm  \nshuffleRows::Bool=false               - randomize Kacmarz algorithm\nseed::Int=1234                      - seed for randomized algorithm\niterations::Int64=10                          - number of iterations\n\nSee also createLinearSolver, solve.\n\n\n\n\n\n","category":"type"},{"location":"API/solvers.html#RegularizedLeastSquares.solve-Tuple{Kaczmarz, Vector{Any}}","page":"Solvers","title":"RegularizedLeastSquares.solve","text":"solve(solver::AbstractLinearSolver, b; solverInfo = nothing, kwargs...)\n\nsolves an inverse problem using solver. When solverInfo is passed to the function information about the iteration process is stored.\n\nSee also SolverInfo.\n\n\n\n\n\nsolve(solver::Kaczmarz, u::Vector; kwargs...)\n\nsolves Tikhonov-regularized inverse problem using Kaczmarz algorithm.\n\nArguments\n\n`solver::Kaczmarz  - the solver containing both system matrix and regularizer\nu::Vector        - data vector\n\nKeywords\n\nS::matT=solver.S                  - operator for the data-term of the problem\nstartVector::Vector{T}=T[]        - initial guess for the solution\nweights::Vector{T}=solver.weights - weights for the data term\nshuffleRows::Bool=false           - randomize Kacmarz algorithm\nsolverInfo=nothing                - solverInfo for logging\n\nwhen a SolverInfo objects is passed, the residuals are stored in solverInfo.convMeas.\n\n\n\n\n\n","category":"method"},{"location":"API/solvers.html#FISTA","page":"Solvers","title":"FISTA","text":"","category":"section"},{"location":"API/solvers.html","page":"Solvers","title":"Solvers","text":"RegularizedLeastSquares.FISTA\nRegularizedLeastSquares.solve(::FISTA, ::Any)","category":"page"},{"location":"API/solvers.html#RegularizedLeastSquares.FISTA","page":"Solvers","title":"RegularizedLeastSquares.FISTA","text":"FISTA(A, x; kwargs...)\n\ncreates a FISTA object for the system matrix A.\n\nArguments\n\nA                     - system matrix\nx::vecT               - (optional) array with the same type and size as the solution\n\nKeywords\n\nreg                   - regularization term vector\nnormalizeReg          - regularization normalization scheme\nAᴴA=A'*A              - specialized normal operator, default is A'*A\nρ=0.95                - step size for gradient step\nnormalize_ρ=true      - normalize step size by the maximum eigenvalue of AᴴA\nt=1.0                 - parameter for predictor-corrector step\nrelTol::=eps(real(T)) - tolerance for stopping criterion\niterations::Int64=50  - maximum number of iterations\nrestart::Symbol=:none - :none, :gradient options for restarting\n\nSee also createLinearSolver, solve.\n\n\n\n\n\n","category":"type"},{"location":"API/solvers.html#RegularizedLeastSquares.solve-Tuple{FISTA, Any}","page":"Solvers","title":"RegularizedLeastSquares.solve","text":"solve(solver::FISTA, b; kwargs...)\n\nsolves an inverse problem using FISTA.\n\nArguments\n\nsolver::FISTA                     - the solver containing both system matrix and regularizer\nb::vecT                           - data vector\n\nKeywords\n\nA=solver.A                        - operator for the data-term of the problem\nstartVector::vecT=similar(b,0)  - initial guess for the solution\nsolverInfo=nothing              - solverInfo object\n\nwhen a SolverInfo objects is passed, the residuals are stored in solverInfo.convMeas.\n\n\n\n\n\n","category":"method"},{"location":"API/solvers.html#OptISTA","page":"Solvers","title":"OptISTA","text":"","category":"section"},{"location":"API/solvers.html","page":"Solvers","title":"Solvers","text":"RegularizedLeastSquares.OptISTA\nRegularizedLeastSquares.solve(::OptISTA, ::Any)","category":"page"},{"location":"API/solvers.html#RegularizedLeastSquares.OptISTA","page":"Solvers","title":"RegularizedLeastSquares.OptISTA","text":"OptISTA(A, x; kwargs...)\n\ncreates a OptISTA object for the system matrix A. OptISTA has a 2x better worst-case bound than FISTA, but actual performance varies by application. It stores 2 extra intermediate variables the size of the image compared to FISTA\n\nReference:\n\nUijeong Jang, Shuvomoy Das Gupta, Ernest K. Ryu,   \"Computer-Assisted Design of Accelerated Composite   Optimization Methods: OptISTA,\" arXiv:2305.15704, 2023,   [https://arxiv.org/abs/2305.15704]\n\nArguments\n\nA                     - system matrix\nx::vecT               - array with the same type and size as the solution\n\nKeywords\n\nreg                   - regularization term vector\nnormalizeReg          - regularization normalization scheme\nAᴴA=A'*A              - specialized normal operator, default is A'*A\nρ=0.95                - step size for gradient step\nnormalize_ρ=true      - normalize step size by the maximum eigenvalue of AᴴA\nθ=1.0                 - parameter for predictor-corrector step\nrelTol::Float64=1.e-5 - tolerance for stopping criterion\niterations::Int64=50  - maximum number of iterations\n\nSee also createLinearSolver, solve.\n\n\n\n\n\n","category":"type"},{"location":"API/solvers.html#RegularizedLeastSquares.solve-Tuple{OptISTA, Any}","page":"Solvers","title":"RegularizedLeastSquares.solve","text":"solve(solver::OptISTA, b::Vector; kwargs...)\n\nsolves an inverse problem using OptISTA.\n\nArguments\n\nsolver::OptISTA                     - the solver containing both system matrix and regularizer\nb::vecT                           - data vector\n\nKeywords\n\nA=solver.A                        - operator for the data-term of the problem\nstartVector::vecT=similar(b,0)  - initial guess for the solution\nsolverInfo=nothing              - solverInfo object\n\nwhen a SolverInfo objects is passed, the residuals are stored in solverInfo.convMeas.\n\n\n\n\n\n","category":"method"},{"location":"API/solvers.html#POGM","page":"Solvers","title":"POGM","text":"","category":"section"},{"location":"API/solvers.html","page":"Solvers","title":"Solvers","text":"RegularizedLeastSquares.POGM\nRegularizedLeastSquares.solve(::POGM, ::Any)","category":"page"},{"location":"API/solvers.html#RegularizedLeastSquares.POGM","page":"Solvers","title":"RegularizedLeastSquares.POGM","text":"POGM(A, x; kwargs...)\n\ncreates a POGM object for the system matrix A. POGM has a 2x better worst-case bound than FISTA, but actual performance varies by application. It stores 3 extra intermediate variables the size of the image compared to FISTA Only gradient restart scheme is implemented for now\n\nReferences:\n\nA.B. Taylor, J.M. Hendrickx, F. Glineur,   \"Exact worst-case performance of first-order algorithms   for composite convex optimization,\" Arxiv:1512.07516, 2015,   SIAM J. Opt. 2017   [http://doi.org/10.1137/16m108104x]\nKim, D., & Fessler, J. A. (2018).   Adaptive Restart of the Optimized Gradient Method for Convex Optimization.   Journal of Optimization Theory and Applications, 178(1), 240–263.   [https://doi.org/10.1007/s10957-018-1287-4]\n\nArguments\n\nA                     - system matrix\nx::vecT               - array with the same type and size as the solution\n\nKeywords\n\nreg                   - regularization term vector\nnormalizeReg          - regularization normalization scheme\nAᴴA=A'*A              - specialized normal operator, default is A'*A\nρ=0.95                - step size for gradient step\nnormalize_ρ=true      - normalize step size by the maximum eigenvalue of AᴴA\nt=1                   - parameter for predictor-corrector step\nσ_fac=1               - parameter for decreasing γ-momentum ∈ [0,1]\nrelTol::=eps(real(T)) - tolerance for stopping criterion\niterations::Int64=50  - maximum number of iterations\nrestart::Symbol=:none - :none, :gradient options for restarting\nverbose::Bool=false   - print residual norm in each iteration\n\nSee also createLinearSolver, solve.\n\n\n\n\n\n","category":"type"},{"location":"API/solvers.html#RegularizedLeastSquares.solve-Tuple{POGM, Any}","page":"Solvers","title":"RegularizedLeastSquares.solve","text":"solve(solver::POGM, b::Vector)\n\nsolves an inverse problem using POGM.\n\nArguments\n\nsolver::POGM                     - the solver containing both system matrix and regularizer\nb::vecT                           - data vector\n\nKeywords\n\nA=solver.A                        - operator for the data-term of the problem\nstartVector::vecT=similar(b,0)  - initial guess for the solution\nsolverInfo=nothing              - solverInfo object\n\nwhen a SolverInfo objects is passed, the residuals are stored in solverInfo.convMeas.\n\n\n\n\n\n","category":"method"},{"location":"API/solvers.html#SplitBregman","page":"Solvers","title":"SplitBregman","text":"","category":"section"},{"location":"API/solvers.html","page":"Solvers","title":"Solvers","text":"RegularizedLeastSquares.SplitBregman\nRegularizedLeastSquares.solve(::SplitBregman, ::Any)","category":"page"},{"location":"API/solvers.html#RegularizedLeastSquares.SplitBregman","page":"Solvers","title":"RegularizedLeastSquares.SplitBregman","text":"SplitBregman(A, x; kwargs...)\n\ncreates a SplitBregman object for the system matrix A.\n\nArguments\n\nA::matT                     - system matrix\nx::vecT                     - Array with the same type and size as the solution\n\nKeywords\n\nreg=nothing          - regularization term vector\nnormalizeReg         - regularization normalization scheme\nprecon=Identity()         - preconditionner for the internal CG algorithm\nρ=[1.e2]                  - weights for condition on regularized variables\niterations::Int64=10      - number of outer iterations\niterationsInner::Int64=50 - maximum number of inner iterations\niterationsCG::Int64=10    - maximum number of CG iterations\nabsTol::Float64=eps()     - abs tolerance for stopping criterion\nrelTol::Float64=eps()     - rel tolerance for stopping criterion\ntolInner::Float64=1.e-5   - tolerance for CG stopping criterion\n\nSee also createLinearSolver, solve.\n\n\n\n\n\n","category":"type"},{"location":"API/solvers.html#RegularizedLeastSquares.solve-Tuple{SplitBregman, Any}","page":"Solvers","title":"RegularizedLeastSquares.solve","text":"solve(solver::AbstractLinearSolver, b; solverInfo = nothing, kwargs...)\n\nsolves an inverse problem using solver. When solverInfo is passed to the function information about the iteration process is stored.\n\nSee also SolverInfo.\n\n\n\n\n\nsolve(solver::SplitBregman, b; kwargs...)\n\nsolves an inverse problem using the Split Bregman method.\n\nArguments\n\nsolver::SplitBregman              - the solver containing both system matrix and regularizer\nb::vecT                           - data vector\n\nKeywords\n\nA::matT=solver.A                - operator for the data-term of the problem\nstartVector::vecT=similar(b,0)  - initial guess for the solution\nsolverInfo=nothing              - solverInfo for logging\n\nwhen a SolverInfo objects is passed, the primal residuals solver.rk and the dual residual norm(solver.sk) are stored in solverInfo.convMeas.\n\n\n\n\n\n","category":"method"},{"location":"API/solvers.html#Direct","page":"Solvers","title":"Direct","text":"","category":"section"},{"location":"index.html#RegularizedLeastSquares.jl","page":"Home","title":"RegularizedLeastSquares.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Solvers for Linear Inverse Problems using Regularization Techniques","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"RegularizedLeastSquares.jl is a Julia package for solving large scale linear systems using different types of algorithms. Ill-conditioned problems arise in many areas of practical interest. To solve these problems, one often resorts to regularization techniques and non-linear problem formulations. This packages provides implementations for a variety of solvers, which are used in fields such as MPI and MRI.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The implemented methods range from the l_2-regularized CGNR method to more general optimizers such as the Alternating Direction of Multipliers Method (ADMM) or the Split-Bregman method.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For convenience, implementations of popular regularizers, such as l_1-regularization and TV regularization, are provided. On the other hand, hand-crafted regularizers can be used quite easily. For this purpose, a Regularization object needs to be build. The latter mainly contains the regularization parameter and a function to calculate the proximal map of a given input.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Depending on the problem, it becomes unfeasible to store the full system matrix at hand. For this purpose, RegularizedLeastSquares.jl allows for the use of matrix-free operators. Such operators can be realized using the interface provided by the package LinearOperators.jl. Other interfaces can be used as well, as long as the product *(A,x) and the adjoint adjoint(A) are provided. A number of common matrix-free operators are provided by the package LinearOperatorColection.jl.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Within Julia, use the package manager:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"RegularizedLeastSquares\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This adds the latest release of the package is added. To install a different version, please consult the Pkg documentation.","category":"page"},{"location":"index.html#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"See Getting Started for an introduction to using the package","category":"page"},{"location":"gettingStarted.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"To get familiar with the different aspects of RegularizedLeastSquares.jl, we will go through a simple example from the field of Compressed Sensing.","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"In Addtion to RegularizedLeastSquares.jl, we will need the packages LinearOperatorCollection.jl, Images.jl and Random.jl, as well as PyPlot for visualization.","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"using RegularizedLeastSquares, LinearOperatorCollection, Images, PyPlot, Random","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"To get started, let us generate a simple phantom","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"N = 256\nI = shepp_logan(N)","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"In this example, we consider an operator which randomly samples half of the pixels in the image. Such an operator and the corresponding measurement can be generated by calling","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"# sampling operator\nidx = sort( shuffle( collect(1:N^2) )[1:div(N^2,2)] )\nA = SamplingOp(eltype(I), pattern = idx , shape = (N,N))\n\n# generate undersampled data\ny = A*vec(I)","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"To recover the image, we solve the TV-regularized least squares problem","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"beginequation\n  undersetmathbfxargmin frac12vertvert mathbfAmathbfx-mathbfy vertvert_2^2 + λTV(mathbfx) \nendequation","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"For this purpose we build a TV regularizer with regularization parameter λ=001","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"reg = TVRegularization(0.01; shape=(N,N))","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"To solve the CS problem, the Alternating Direction Method of Multipliers can be used. Thus, we build the corresponding solver","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"solver = createLinearSolver(ADMM, A; reg=reg, ρ=0.1, iterations=20)","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"and apply it to our measurement","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"Ireco = solve(solver,y)\nIreco = reshape(Ireco,N,N)","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"The original phantom and the reconstructed image are shown below","category":"page"},{"location":"gettingStarted.html","page":"Getting Started","title":"Getting Started","text":"(Image: Phantom) (Image: Reconstruction)","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"DocTestSetup = quote\n    using RegularizedLeastSquares, Wavelets, LinearOperatorCollection\nend","category":"page"},{"location":"regularization.html#Regularization","page":"Regularization","title":"Regularization","text":"","category":"section"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"When formulating inverse problems, a Regularizer is formulated as an additional term in a cost function, which has to be minimized. Popular optimizers often deal with a regularizers g, by computing the proximal map","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"beginequation\n  prox_g (mathbfx) = undersetmathbfuargmin frac12vertvert mathbfu-mathbfx vert vert^2 + g(mathbfx)\nendequation","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"In order to implement those kinds of algorithms,RegularizedLeastSquares defines the following type hierarchy:","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"abstract type AbstractRegularization\nprox!(reg::AbstractRegularization, x)\nnorm(reg::AbstractRegularization, x)","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"Here prox!(reg, x) is an in-place function which computes the proximal map on the input-vector x. The function norm computes the value of the corresponding term in the inverse problem. RegularizedLeastSquares.jl provides AbstractParameterizedRegularization and AbstractProjectionRegularization as core regularization types.","category":"page"},{"location":"regularization.html#Parameterized-Regularization-Terms","page":"Regularization","title":"Parameterized Regularization Terms","text":"","category":"section"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"This group of regularization terms features a regularization parameter λ that is used during the prox! and normcomputations. Examples of this regulariztion group are L1, L2 or LLR (locally low rank) regularization terms.","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"These terms are constructed by supplying a λ and optionally term specific keyword arguments:","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"julia> l2 = L2Regularization(0.3)\nL2Regularization{Float64}(0.3)","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"Parameterized regularization terms implement:","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"prox!(reg::AbstractParameterizedRegularization, x, λ)\nnorm(reg::AbstractParameterizedRegularization, x, λ)","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"where λ by default is filled with the value used during construction.","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"Invoking λ on a parameterized term retrieves its regularization parameter. This can be used in a solver to scale and overwrite the parameter as follows:","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"julia> prox!(l2, [1.0])\n1-element Vector{Float64}:\n 0.625\n\njulia> param = λ(l2)\n0.3\n\njulia> prox!(l2, [1.0], param*0.2)\n1-element Vector{Float64}:\n 0.8928571428571428\n","category":"page"},{"location":"regularization.html#Projection-Regularization-Terms","page":"Regularization","title":"Projection Regularization Terms","text":"","category":"section"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"This group of regularization terms implement projections, such as a positivity constraint or a projection with a given convex projection function.","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"julia> positive = PositiveRegularization()\nPositiveRegularization()\n\njulia> prox!(positive, [2.0, -0.2])\n2-element Vector{Float64}:\n 2.0\n 0.0","category":"page"},{"location":"regularization.html#Nested-Regularization-Terms","page":"Regularization","title":"Nested Regularization Terms","text":"","category":"section"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"Nested regularization terms are terms that act as decorators to the core regularization terms. These terms can be nested around other terms and add functionality to a regularization term, such as scaling λ based on the provided system matrix or applying a transform, such as the Wavelet, to x:","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"julia> core = L1Regularization(0.8)\nL1Regularization{Float64}(0.8)\n\njulia> wop = WaveletOp(Float32, shape = (32,32));\n\njulia> reg = TransformedRegularization(core, wop);\n\njulia> prox!(reg, randn(32*32)); # Apply soft-thresholding in Wavelet domain","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"The type of regularization term a nested term can be wrapped around depends on the concrete type of the nested term. However generally, they can be nested arbitrarly deep, adding new functionality with each layer. Each nested regularization term can return its inner regularization. Furthermore, all regularization terms implement the iteration interface to iterate over the nesting. The innermost regularization term of a nested term must be a core regularization term and it can be returned by the sink function:","category":"page"},{"location":"regularization.html","page":"Regularization","title":"Regularization","text":"julia> RegularizedLeastSquares.innerreg(reg) == core\ntrue\n\njulia> sink(reg) == core\ntrue\n\njulia> foreach(r -> println(nameof(typeof(r))), reg)\nTransformedRegularization\nL1Regularization","category":"page"}]
}
