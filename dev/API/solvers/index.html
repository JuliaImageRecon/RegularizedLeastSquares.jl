<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · RegularizedLeastSquares.jl</title><meta name="title" content="Solvers · RegularizedLeastSquares.jl"/><meta property="og:title" content="Solvers · RegularizedLeastSquares.jl"/><meta property="twitter:title" content="Solvers · RegularizedLeastSquares.jl"/><meta name="description" content="Documentation for RegularizedLeastSquares.jl."/><meta property="og:description" content="Documentation for RegularizedLeastSquares.jl."/><meta property="twitter:description" content="Documentation for RegularizedLeastSquares.jl."/><meta property="og:url" content="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/API/solvers/"/><meta property="twitter:url" content="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/API/solvers/"/><link rel="canonical" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/API/solvers/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RegularizedLeastSquares.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../gettingStarted/">Getting Started</a></li><li><a class="tocitem" href="../../solvers/">Solvers</a></li><li><a class="tocitem" href="../../regularization/">Regularization</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>Solvers</a><ul class="internal"><li><a class="tocitem" href="#solve!"><span>solve!</span></a></li><li><a class="tocitem" href="#ADMM"><span>ADMM</span></a></li><li><a class="tocitem" href="#CGNR"><span>CGNR</span></a></li><li><a class="tocitem" href="#Kaczmarz"><span>Kaczmarz</span></a></li><li><a class="tocitem" href="#FISTA"><span>FISTA</span></a></li><li><a class="tocitem" href="#OptISTA"><span>OptISTA</span></a></li><li><a class="tocitem" href="#POGM"><span>POGM</span></a></li><li><a class="tocitem" href="#SplitBregman"><span>SplitBregman</span></a></li><li><a class="tocitem" href="#Miscellaneous-Functions"><span>Miscellaneous Functions</span></a></li></ul></li><li><a class="tocitem" href="../regularization/">Regularization Terms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/master/docs/src/API/solvers.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-for-Solvers"><a class="docs-heading-anchor" href="#API-for-Solvers">API for Solvers</a><a id="API-for-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#API-for-Solvers" title="Permalink"></a></h1><p>This page contains documentation of the public API of the RegularizedLeastSquares. In the Julia REPL one can access this documentation by entering the help mode with <code>?</code></p><h2 id="solve!"><a class="docs-heading-anchor" href="#solve!">solve!</a><a id="solve!-1"></a><a class="docs-heading-anchor-permalink" href="#solve!" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.solve!-Tuple{AbstractLinearSolver, Any}" href="#RegularizedLeastSquares.solve!-Tuple{AbstractLinearSolver, Any}"><code>RegularizedLeastSquares.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(solver::AbstractLinearSolver, b; x0 = 0, callbacks = (_, _) -&gt; nothing)</code></pre><p>Solves an inverse problem for the data vector <code>b</code> using <code>solver</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>solver::AbstractLinearSolver</code>    - linear solver (e.g., <code>ADMM</code> or <code>FISTA</code>), containing forward/normal operator and regularizer</li><li><code>b::AbstractVector</code>               - data vector if <code>A</code> was supplied to the solver, back-projection of the data otherwise</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>x0::AbstractVector</code>              - initial guess for the solution; default is zero</li><li><code>callbacks</code>              - (optionally a vector of) function or callable struct that takes the two arguments <code>callback(solver, iteration)</code> and, e.g., stores, prints, or plots the intermediate solutions or convergence parameters. Be sure not to modify <code>solver</code> or <code>iteration</code> in the callback function as this would japaridze convergence. The default does nothing.</li></ul><p><strong>Examples</strong></p><p>The optimization problem</p><p class="math-container">\[	argmin_x ||Ax - b||_2^2 + λ ||x||_1\]</p><p>can be solved with the following lines of code:</p><pre><code class="language-julia-repl hljs">julia&gt; using RegularizedLeastSquares

julia&gt; A = [0.831658  0.96717
            0.383056  0.39043
            0.820692  0.08118];

julia&gt; x = [0.5932234523399985; 0.2697534345340015];

julia&gt; b = A * x;

julia&gt; S = ADMM(A);

julia&gt; x_approx = solve!(S, b)
2-element Vector{Float64}:
 0.5932234523399984
 0.26975343453400163</code></pre><p>Here, we use <a href="../regularization/#RegularizedLeastSquares.L1Regularization"><code>L1Regularization</code></a>, which is default for <a href="#ADMM"><code>ADMM</code></a>. All regularization options can be found in <a href="../regularization/#API-for-Regularizers">API for Regularizers</a>.</p><p>The following example solves the same problem, but stores the solution <code>x</code> of each interation in <code>tr</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; tr = Dict[]
Dict[]

julia&gt; store_trace!(tr, solver, iteration) = push!(tr, Dict(&quot;iteration&quot; =&gt; iteration, &quot;x&quot; =&gt; solver.x, &quot;beta&quot; =&gt; solver.β))
store_trace! (generic function with 1 method)

julia&gt; x_approx = solve!(S, b; callbacks=(solver, iteration) -&gt; store_trace!(tr, solver, iteration))
2-element Vector{Float64}:
 0.5932234523399984
 0.26975343453400163

julia&gt; tr[3]
Dict{String, Any} with 3 entries:
  &quot;iteration&quot; =&gt; 2
  &quot;x&quot;         =&gt; [0.593223, 0.269753]
  &quot;beta&quot;      =&gt; [1.23152, 0.927611]</code></pre><p>The last example show demonstrates how to plot the solution at every 10th iteration and store the solvers convergence metrics:</p><pre><code class="language-julia hljs">julia&gt; using Plots

julia&gt; conv = StoreConvergenceCallback()

julia&gt; function plot_trace(solver, iteration)
         if iteration % 10 == 0
           display(scatter(solver.x))
         end
       end
plot_trace (generic function with 1 method)

julia&gt; x_approx = solve!(S, b; callbacks = [conv, plot_trace]);</code></pre><p>The keyword <code>callbacks</code> allows you to pass a (vector of) callable objects that takes the arguments <code>solver</code> and <code>iteration</code> and prints, stores, or plots intermediate result.</p><p>See also <a href="#RegularizedLeastSquares.StoreSolutionCallback"><code>StoreSolutionCallback</code></a>, <a href="#RegularizedLeastSquares.StoreConvergenceCallback"><code>StoreConvergenceCallback</code></a>, <a href="#RegularizedLeastSquares.CompareSolutionCallback"><code>CompareSolutionCallback</code></a> for a number of provided callback options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/RegularizedLeastSquares.jl#L22-L100">source</a></section></article><h2 id="ADMM"><a class="docs-heading-anchor" href="#ADMM">ADMM</a><a id="ADMM-1"></a><a class="docs-heading-anchor-permalink" href="#ADMM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.ADMM" href="#RegularizedLeastSquares.ADMM"><code>RegularizedLeastSquares.ADMM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ADMM(A; AHA = A&#39;*A, precon = Identity(), reg = L1Regularization(zero(real(eltype(AHA)))), regTrafo = opEye(eltype(AHA), size(AHA,1)), normalizeReg = NoNormalization(), rho = 1e-1, vary_rho = :none, iterations = 10, iterationsCG = 10, absTol = eps(real(eltype(AHA))), relTol = eps(real(eltype(AHA))), tolInner = 1e-5, verbose = false)
ADMM( ; AHA = ,     precon = Identity(), reg = L1Regularization(zero(real(eltype(AHA)))), regTrafo = opEye(eltype(AHA), size(AHA,1)), normalizeReg = NoNormalization(), rho = 1e-1, vary_rho = :none, iterations = 10, iterationsCG = 10, absTol = eps(real(eltype(AHA))), relTol = eps(real(eltype(AHA))), tolInner = 1e-5, verbose = false)</code></pre><p>Creates an <code>ADMM</code> object for the forward operator <code>A</code> or normal operator <code>AHA</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p>OR</p><ul><li><code>AHA</code>                                               - normal operator (as a keyword argument)</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>precon</code>                                            - preconditionner for the internal CG algorithm</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term; can also be a vector of regularization terms</li><li><code>regTrafo</code>                                          - transformation to a space in which <code>reg</code> is applied; if <code>reg</code> is a vector, <code>regTrafo</code> has to be a vector of the same length. Use <code>opEye(eltype(AHA), size(AHA,1))</code> if no transformation is desired.</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>rho::Real</code>                                         - penalty of the augmented Lagrangian</li><li><code>vary_rho::Symbol</code>                                  - vary rho to balance primal and dual feasibility; options <code>:none</code>, <code>:balance</code>, <code>:PnP</code></li><li><code>iterations::Int</code>                                   - maximum number of (outer) ADMM iterations</li><li><code>iterationsCG::Int</code>                                 - maximum number of (inner) CG iterations</li><li><code>absTol::Real</code>                                      - absolute tolerance for stopping criterion</li><li><code>relTol::Real</code>                                      - relative tolerance for stopping criterion</li><li><code>tolInner::Real</code>                                    - relative tolerance for CG stopping criterion</li><li><code>verbose::Bool</code>                                     - print residual in each iteration</li></ul><p>ADMM differs from ISTA-type algorithms in the sense that the proximal operation is applied separately from the transformation to the space in which the penalty is applied. This is reflected by the interface which has <code>reg</code> and <code>regTrafo</code> as separate arguments. E.g., for a TV penalty, you should NOT set <code>reg=TVRegularization</code>, but instead use <code>reg=L1Regularization(λ), regTrafo=RegularizedLeastSquares.GradientOp(Float64; shape=(Nx,Ny,Nz))</code>.</p><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#solve!"><code>solve!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/ADMM.jl#L42-L71">source</a></section></article><h2 id="CGNR"><a class="docs-heading-anchor" href="#CGNR">CGNR</a><a id="CGNR-1"></a><a class="docs-heading-anchor-permalink" href="#CGNR" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.CGNR" href="#RegularizedLeastSquares.CGNR"><code>RegularizedLeastSquares.CGNR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CGNR(A; AHA = A&#39; * A, reg = L2Regularization(zero(real(eltype(AHA)))), normalizeReg = NoNormalization(), iterations = 10, relTol = eps(real(eltype(AHA))))
CGNR( ; AHA = ,       reg = L2Regularization(zero(real(eltype(AHA)))), normalizeReg = NoNormalization(), iterations = 10, relTol = eps(real(eltype(AHA))))</code></pre><p>creates an <code>CGNR</code> object for the forward operator <code>A</code> or normal operator <code>AHA</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p>OR</p><ul><li><code>AHA</code>                                               - normal operator (as a keyword argument)</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term; can also be a vector of regularization terms</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>iterations::Int</code>                                   - maximum number of iterations</li><li><code>relTol::Real</code>                                      - tolerance for stopping criterion</li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#solve!"><code>solve!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/CGNR.jl#L21-L40">source</a></section></article><h2 id="Kaczmarz"><a class="docs-heading-anchor" href="#Kaczmarz">Kaczmarz</a><a id="Kaczmarz-1"></a><a class="docs-heading-anchor-permalink" href="#Kaczmarz" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.Kaczmarz" href="#RegularizedLeastSquares.Kaczmarz"><code>RegularizedLeastSquares.Kaczmarz</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Kaczmarz(A; reg = L2Regularization(0), normalizeReg = NoNormalization(), randomized=false, subMatrixFraction=0.15, shuffleRows=false, seed=1234, iterations=10)</code></pre><p>Creates a Kaczmarz object for the forward operator <code>A</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>randomized::Bool</code>                                    - randomize Kacmarz algorithm</li><li><code>subMatrixFraction::Real</code>                             - fraction of rows used in randomized Kaczmarz algorithm</li><li><code>shuffleRows::Bool</code>                                   - randomize Kacmarz algorithm</li><li><code>seed::Int</code>                                           - seed for randomized algorithm</li><li><code>iterations::Int</code>                                     - number of iterations</li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#solve!"><code>solve!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/Kaczmarz.jl#L26-L44">source</a></section></article><h2 id="FISTA"><a class="docs-heading-anchor" href="#FISTA">FISTA</a><a id="FISTA-1"></a><a class="docs-heading-anchor-permalink" href="#FISTA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.FISTA" href="#RegularizedLeastSquares.FISTA"><code>RegularizedLeastSquares.FISTA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FISTA(A; AHA=A&#39;*A, reg=L1Regularization(zero(real(eltype(AHA)))), normalizeReg=NoNormalization(), rho=0.95, normalize_rho=true, theta=1, relTol=eps(real(eltype(AHA))), iterations=50, restart = :none, verbose = false)
FISTA( ; AHA=,     reg=L1Regularization(zero(real(eltype(AHA)))), normalizeReg=NoNormalization(), rho=0.95, normalize_rho=true, theta=1, relTol=eps(real(eltype(AHA))), iterations=50, restart = :none, verbose = false)</code></pre><p>creates a <code>FISTA</code> object for the forward operator <code>A</code> or normal operator <code>AHA</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p>OR</p><ul><li><code>AHA</code>                                               - normal operator (as a keyword argument)</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>precon</code>                                            - preconditionner for the internal CG algorithm</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term; can also be a vector of regularization terms</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>rho::Real</code>                                         - step size for gradient step</li><li><code>normalize_rho::Bool</code>                               - normalize step size by the largest eigenvalue of <code>AHA</code></li><li><code>theta::Real</code>                                       - parameter for predictor-corrector step</li><li><code>relTol::Real</code>                                      - tolerance for stopping criterion</li><li><code>iterations::Int</code>                                   - maximum number of iterations</li><li><code>restart::Symbol</code>                                   - <code>:none</code>, <code>:gradient</code> options for restarting</li><li><code>verbose::Bool</code>                                     - print residual in each iteration</li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#solve!"><code>solve!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/FISTA.jl#L24-L49">source</a></section></article><h2 id="OptISTA"><a class="docs-heading-anchor" href="#OptISTA">OptISTA</a><a id="OptISTA-1"></a><a class="docs-heading-anchor-permalink" href="#OptISTA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.OptISTA" href="#RegularizedLeastSquares.OptISTA"><code>RegularizedLeastSquares.OptISTA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OptISTA(A; AHA=A&#39;*A, reg=L1Regularization(zero(real(eltype(AHA)))), normalizeReg=NoNormalization(), rho=0.95, normalize_rho=true, theta=1, relTol=eps(real(eltype(AHA))), iterations=50, verbose = false)
OptISTA( ; AHA=,     reg=L1Regularization(zero(real(eltype(AHA)))), normalizeReg=NoNormalization(), rho=0.95, normalize_rho=true, theta=1, relTol=eps(real(eltype(AHA))), iterations=50, verbose = false)</code></pre><p>creates a <code>OptISTA</code> object for the forward operator <code>A</code> or normal operator <code>AHA</code>. OptISTA has a 2x better worst-case bound than FISTA, but actual performance varies by application. It stores 2 extra intermediate variables the size of the image compared to FISTA.</p><p>Reference:</p><ul><li>Uijeong Jang, Shuvomoy Das Gupta, Ernest K. Ryu, &quot;Computer-Assisted Design of Accelerated Composite Optimization Methods: OptISTA,&quot; arXiv:2305.15704, 2023, [https://arxiv.org/abs/2305.15704]</li></ul><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p>OR</p><ul><li><code>AHA</code>                                               - normal operator (as a keyword argument)</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>rho::Real</code>                                         - step size for gradient step</li><li><code>normalize_rho::Bool</code>                               - normalize step size by the largest eigenvalue of <code>AHA</code></li><li><code>theta::Real</code>                                       - parameter for predictor-corrector step</li><li><code>relTol::Real</code>                                      - tolerance for stopping criterion</li><li><code>iterations::Int</code>                                   - maximum number of iterations</li><li><code>verbose::Bool</code>                                     - print residual in each iteration</li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#solve!"><code>solve!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/OptISTA.jl#L29-L55">source</a></section></article><h2 id="POGM"><a class="docs-heading-anchor" href="#POGM">POGM</a><a id="POGM-1"></a><a class="docs-heading-anchor-permalink" href="#POGM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.POGM" href="#RegularizedLeastSquares.POGM"><code>RegularizedLeastSquares.POGM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">POGM(A; AHA = A&#39;*A, reg = L1Regularization(zero(real(eltype(AHA)))), normalizeReg = NoNormalization(), rho = 0.95, normalize_rho = true, theta = 1, sigma_fac = 1, relTol = eps(real(eltype(AHA))), iterations = 50, restart = :none, verbose = false)
POGM( ; AHA = ,     reg = L1Regularization(zero(real(eltype(AHA)))), normalizeReg = NoNormalization(), rho = 0.95, normalize_rho = true, theta = 1, sigma_fac = 1, relTol = eps(real(eltype(AHA))), iterations = 50, restart = :none, verbose = false)</code></pre><p>Creates a <code>POGM</code> object for the forward operator <code>A</code> or normal operator <code>AHA</code>. POGM has a 2x better worst-case bound than FISTA, but actual performance varies by application. It stores 3 extra intermediate variables the size of the image compared to FISTA. Only gradient restart scheme is implemented for now.</p><p><strong>References:</strong></p><ul><li><p>A.B. Taylor, J.M. Hendrickx, F. Glineur,   &quot;Exact worst-case performance of first-order algorithms   for composite convex optimization,&quot; Arxiv:1512.07516, 2015,   SIAM J. Opt. 2017   [http://doi.org/10.1137/16m108104x]</p></li><li><p>Kim, D., &amp; Fessler, J. A. (2018).   Adaptive Restart of the Optimized Gradient Method for Convex Optimization.   Journal of Optimization Theory and Applications, 178(1), 240–263.   [https://doi.org/10.1007/s10957-018-1287-4]</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p>OR</p><ul><li><code>AHA</code>                                               - normal operator (as a keyword argument)</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>rho::Real</code>                                         - step size for gradient step</li><li><code>normalize_rho::Bool</code>                               - normalize step size by the largest eigenvalue of <code>AHA</code></li><li><code>theta::Real</code>                                       - parameter for predictor-corrector step</li><li><code>sigma_fac::Real</code>                                   - parameter for decreasing γ-momentum ∈ [0,1]</li><li><code>relTol::Real</code>                                      - tolerance for stopping criterion</li><li><code>iterations::Int</code>                                   - maximum number of iterations</li><li><code>restart::Symbol</code>                                   - <code>:none</code>, <code>:gradient</code> options for restarting</li><li><code>verbose::Bool</code>                                     - print residual in each iteration</li></ul></li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#solve!"><code>solve!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/POGM.jl#L33-L69">source</a></section></article><h2 id="SplitBregman"><a class="docs-heading-anchor" href="#SplitBregman">SplitBregman</a><a id="SplitBregman-1"></a><a class="docs-heading-anchor-permalink" href="#SplitBregman" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.SplitBregman" href="#RegularizedLeastSquares.SplitBregman"><code>RegularizedLeastSquares.SplitBregman</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplitBregman(A; AHA = A&#39;*A, precon = Identity(), reg = L1Regularization(zero(real(eltype(AHA)))), regTrafo = opEye(eltype(AHA), size(AHA,1)), normalizeReg = NoNormalization(), rho = 1e-1, iterationsOuter = 10, iterationsInner = 10, iterationsCG = 10, absTol = eps(real(eltype(AHA))), relTol = eps(real(eltype(AHA))), tolInner = 1e-5, verbose = false)
SplitBregman( ; AHA = ,     precon = Identity(), reg = L1Regularization(zero(real(eltype(AHA)))), regTrafo = opEye(eltype(AHA), size(AHA,1)), normalizeReg = NoNormalization(), rho = 1e-1, iterationsOuter = 10, iterationsInner = 10, iterationsCG = 10, absTol = eps(real(eltype(AHA))), relTol = eps(real(eltype(AHA))), tolInner = 1e-5, verbose = false)</code></pre><p>Creates a <code>SplitBregman</code> object for the forward operator <code>A</code> or normal operator <code>AHA</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p>OR</p><ul><li><code>AHA</code>                                               - normal operator (as a keyword argument)</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>precon</code>                                            - preconditionner for the internal CG algorithm</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term; can also be a vector of regularization terms</li><li><code>regTrafo</code>                                          - transformation to a space in which <code>reg</code> is applied; if <code>reg</code> is a vector, <code>regTrafo</code> has to be a vector of the same length. Use <code>opEye(eltype(AHA), size(AHA,1))</code> if no transformation is desired.</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>rho::Real</code>                                         - weights for condition on regularized variables; can also be a vector for multiple regularization terms</li><li><code>iterationsOuter::Int</code>                              - maximum number of outer iterations. Set to 1 for unconstraint split Bregman (equivalent to ADMM)</li><li><code>iterationsInner::Int</code>                              - maximum number of inner iterations</li><li><code>iterationsCG::Int</code>                                 - maximum number of (inner) CG iterations</li><li><code>absTol::Real</code>                                      - absolute tolerance for stopping criterion</li><li><code>relTol::Real</code>                                      - relative tolerance for stopping criterion</li><li><code>tolInner::Real</code>                                    - relative tolerance for CG stopping criterion</li><li><code>verbose::Bool</code>                                     - print residual in each iteration</li></ul><p>This algorithm solves the constraint problem (Eq. (4.7) in <a href="https://doi.org/10.1137/080725891">Tom Goldstein and Stanley Osher</a>), i.e. <code>||R(x)||₁</code> such that <code>||Ax -b||₂² &lt; σ²</code>. In order to solve the unconstraint problem (Eq. (4.8) in <a href="https://doi.org/10.1137/080725891">Tom Goldstein and Stanley Osher</a>), i.e. <code>||Ax -b||₂² + λ ||R(x)||₁</code>, you can either set <code>iterationsOuter=1</code> or use ADMM instead, which is equivalent (<code>iterationsOuter=1</code> in SplitBregman in implied in ADMM and the SplitBregman variable <code>iterationsInner</code> is simply called <code>iterations</code> in ADMM)</p><p>Like ADMM, SplitBregman differs from ISTA-type algorithms in the sense that the proximal operation is applied separately from the transformation to the space in which the penalty is applied. This is reflected by the interface which has <code>reg</code> and <code>regTrafo</code> as separate arguments. E.g., for a TV penalty, you should NOT set <code>reg=TVRegularization</code>, but instead use <code>reg=L1Regularization(λ), regTrafo=RegularizedLeastSquares.GradientOp(Float64; shape=(Nx,Ny,Nz))</code>.</p><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#solve!"><code>solve!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/SplitBregman.jl#L42-L73">source</a></section></article><h2 id="Miscellaneous-Functions"><a class="docs-heading-anchor" href="#Miscellaneous-Functions">Miscellaneous Functions</a><a id="Miscellaneous-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.StoreSolutionCallback" href="#RegularizedLeastSquares.StoreSolutionCallback"><code>RegularizedLeastSquares.StoreSolutionCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StoreSolutionCallback(T)</code></pre><p>Callback that accumlates the solvers <code>solution</code> per iteration. Results are stored in the <code>solutions</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/Callbacks.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.StoreConvergenceCallback" href="#RegularizedLeastSquares.StoreConvergenceCallback"><code>RegularizedLeastSquares.StoreConvergenceCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StoreConvergenceCallback()</code></pre><p>Callback that accumlates the solvers convergence metrics per iteration. Results are stored in the <code>convMeas</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/Callbacks.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.CompareSolutionCallback" href="#RegularizedLeastSquares.CompareSolutionCallback"><code>RegularizedLeastSquares.CompareSolutionCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompareSolutionCallback(ref, cmp)</code></pre><p>Callback that compares the solvers current <code>solution</code> with the given reference via <code>cmp(ref, solution)</code> per iteration. Results are stored in the <code>results</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/Callbacks.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.linearSolverList" href="#RegularizedLeastSquares.linearSolverList"><code>RegularizedLeastSquares.linearSolverList</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a list of all available linear solvers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/RegularizedLeastSquares.jl#L186-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.createLinearSolver" href="#RegularizedLeastSquares.createLinearSolver"><code>RegularizedLeastSquares.createLinearSolver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">createLinearSolver(solver::AbstractLinearSolver, A; kargs...)</code></pre><p>This method creates a solver. The supported solvers are methods typically used for solving regularized linear systems. All solvers return an approximate solution to Ax = b.</p><p>TODO: give a hint what solvers are available</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/RegularizedLeastSquares.jl#L255-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.applicableSolverList" href="#RegularizedLeastSquares.applicableSolverList"><code>RegularizedLeastSquares.applicableSolverList</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">applicable(args...)</code></pre><p>list all <code>solvers</code> that are applicable to the given arguments. Arguments are the same as for <code>isapplicable</code> without the <code>solver</code> type.</p><p>See also <a href="#RegularizedLeastSquares.isapplicable"><code>isapplicable</code></a>, <a href="#RegularizedLeastSquares.linearSolverList"><code>linearSolverList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/RegularizedLeastSquares.jl#L233-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.isapplicable" href="#RegularizedLeastSquares.isapplicable"><code>RegularizedLeastSquares.isapplicable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isapplicable(solverType::Type{&lt;:AbstractLinearSolver}, A, x, reg)</code></pre><p>return <code>true</code> if a <code>solver</code> of type <code>solverType</code> is applicable to system matrix <code>A</code>, data <code>x</code> and regularization terms <code>reg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/30b2438ef68ee81cd86b2b9180d857b2c67fdf21/src/RegularizedLeastSquares.jl#L226-L230">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../regularization/">« Regularization</a><a class="docs-footer-nextpage" href="../regularization/">Regularization Terms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 24 May 2024 13:49">Friday 24 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
