<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · RegularizedLeastSquares.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RegularizedLeastSquares.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../gettingStarted.html">Getting Started</a></li><li><a class="tocitem" href="../solvers.html">Solvers</a></li><li><a class="tocitem" href="../regularization.html">Regularization</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href="solvers.html">Solvers</a><ul class="internal"><li><a class="tocitem" href="#General"><span>General</span></a></li><li><a class="tocitem" href="#ADMM"><span>ADMM</span></a></li><li><a class="tocitem" href="#CGNR"><span>CGNR</span></a></li><li><a class="tocitem" href="#Kaczmarz"><span>Kaczmarz</span></a></li><li><a class="tocitem" href="#FISTA"><span>FISTA</span></a></li><li><a class="tocitem" href="#OptISTA"><span>OptISTA</span></a></li><li><a class="tocitem" href="#POGM"><span>POGM</span></a></li><li><a class="tocitem" href="#SplitBregman"><span>SplitBregman</span></a></li><li><a class="tocitem" href="#Direct"><span>Direct</span></a></li></ul></li><li><a class="tocitem" href="regularization.html">Regularization Terms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="solvers.html">Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="solvers.html">Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/master/docs/src/API/solvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>This page contains documentation of the public API of the RegularizedLeastSquares. In the Julia REPL one can access this documentation by entering the help mode with <code>?</code></p><h2 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.linearSolverList" href="#RegularizedLeastSquares.linearSolverList"><code>RegularizedLeastSquares.linearSolverList</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a list of all available linear solvers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/RegularizedLeastSquares.jl#L67-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.createLinearSolver" href="#RegularizedLeastSquares.createLinearSolver"><code>RegularizedLeastSquares.createLinearSolver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">createLinearSolver(solver::AbstractLinearSolver, A; log::Bool=false, kargs...)</code></pre><p>This method creates a solver. The supported solvers are methods typically used for solving regularized linear systems. All solvers return an approximate solution to Ax = b.</p><p>TODO: give a hint what solvers are available</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/RegularizedLeastSquares.jl#L123-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}" href="#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>RegularizedLeastSquares.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(solver::AbstractLinearSolver, b; solverInfo = nothing, kwargs...)</code></pre><p>solves an inverse problem using <code>solver</code>. When <code>solverInfo</code> is passed to the function information about the iteration process is stored.</p><p>See also <a href="solvers.html#RegularizedLeastSquares.SolverInfo"><code>SolverInfo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/RegularizedLeastSquares.jl#L23-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.SolverInfo" href="#RegularizedLeastSquares.SolverInfo"><code>RegularizedLeastSquares.SolverInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Solver Info type is used to obtain aditional information of linear solvers and their iteration process.</p><p><strong>Fields</strong></p><ul><li><code>convMeas::Vector{Float64}</code> - Vector with convergence parameters</li><li><code>nrmse::Vector{Float64}</code>    - NRMSD of the current iterate w.r.t some reference (if provided)</li><li><code>x_ref::Vector{T}</code>          - Reference for computing NRMSD of iterates</li><li><code>x_iter::Vector{Vector{T}}</code> - Vector for storing iterates</li><li><code>store_solutions::Bool</code>     - specification whether iterates are to be stored</li></ul><p>the content of <code>convMeas</code> is specific to each solver. It can be found in the documentation of the corresping <code>solve</code>-method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/Utils.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.applicableSolverList" href="#RegularizedLeastSquares.applicableSolverList"><code>RegularizedLeastSquares.applicableSolverList</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applicable(args...)</code></pre><p>list all <code>solvers</code> that are applicable to the given arguments. Arguments are the same as for <code>isapplicable</code> without the <code>solver</code> type.</p><p>See also <a href="solvers.html#RegularizedLeastSquares.isapplicable"><code>isapplicable</code></a>, <a href="solvers.html#RegularizedLeastSquares.linearSolverList"><code>linearSolverList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/RegularizedLeastSquares.jl#L114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.isapplicable" href="#RegularizedLeastSquares.isapplicable"><code>RegularizedLeastSquares.isapplicable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isapplicable(solverType::Type{&lt;:AbstractLinearSolver}, A, x, reg)</code></pre><p>return <code>true</code> if a <code>solver</code> of type <code>solverType</code> is applicable to system matrix <code>A</code>, data <code>x</code> and regularization terms <code>reg</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/RegularizedLeastSquares.jl#L107-L111">source</a></section></article><h2 id="ADMM"><a class="docs-heading-anchor" href="#ADMM">ADMM</a><a id="ADMM-1"></a><a class="docs-heading-anchor-permalink" href="#ADMM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.ADMM" href="#RegularizedLeastSquares.ADMM"><code>RegularizedLeastSquares.ADMM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ADMM(A, x; kwargs...)</code></pre><p>creates an <code>ADMM</code> object for the system matrix <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>                           - system matrix</li><li><code>x</code>                     - (optional) array with the same type and size as the solution</li></ul><p><strong>Keywords</strong></p><ul><li><code>reg</code>          - regularization term vector</li><li><code>normalizeReg</code>         - regularization normalization scheme</li><li><code>precon=Identity()</code>        - preconditionner for the internal CG algorithm</li><li><code>ρ::Real=1.e-2</code>          - penalty of the augmented lagrangian</li><li><code>vary_ρ::Bool=:none</code>      - vary rho to balance primal and dual feasibility</li><li><code>iterations::Int64=50</code>      - max number of ADMM iterations</li><li><code>iterationsInner::Int64=10</code> - max number of internal CG iterations</li><li><code>absTol::Real=eps()</code>     - abs tolerance for stopping criterion</li><li><code>relTol::Real=eps()</code>     - rel tolerance for stopping criterion</li><li><code>tolInner::Real=1.e-5</code>   - rel tolerance for CG stopping criterion</li></ul><p>See also <a href="solvers.html#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="solvers.html#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/ADMM.jl#L42-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.solve-Tuple{ADMM, Any}" href="#RegularizedLeastSquares.solve-Tuple{ADMM, Any}"><code>RegularizedLeastSquares.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(solver::ADMM, b; kwargs...) where {matT,vecT}</code></pre><p>solves an inverse problem using ADMM.</p><p><strong>Arguments</strong></p><ul><li><code>solver::ADMM</code>                  - the solver containing both system matrix and regularizer</li><li><code>b::Vector</code>                     - data vector</li></ul><p><strong>Keywords</strong></p><ul><li><code>A::matT=solver.A</code>            - operator for the data-term of the problem</li><li><code>startVector::Vector{T}=T[]</code>  - initial guess for the solution</li><li><code>solverInfo=nothing</code>          - solverInfo for logging</li></ul><p>when a <code>SolverInfo</code> objects is passed, the primal residuals <code>solver.rᵏ</code> and the dual residual <code>norm(solver.sᵏ)</code> are stored in <code>solverInfo.convMeas</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/ADMM.jl#L194-L210">source</a></section></article><h2 id="CGNR"><a class="docs-heading-anchor" href="#CGNR">CGNR</a><a id="CGNR-1"></a><a class="docs-heading-anchor-permalink" href="#CGNR" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.CGNR" href="#RegularizedLeastSquares.CGNR"><code>RegularizedLeastSquares.CGNR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CGNR(A, x; kargs...)</code></pre><p>creates an <code>CGNR</code> object for the system matrix <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>                               - system matrix</li><li><code>x::vecT</code>                         - (optional) array with the same type and size as the solution</li></ul><p><strong>Keywords</strong></p><ul><li><code>reg</code>   - regularization term vector</li><li><code>normalizeReg</code>         - regularization normalization scheme</li><li><code>weights::vecT=eltype(A)[]</code> - weights for the data term</li><li><code>AᴴA=A&#39;*A</code>              - specialized normal operator, default is <code>A&#39;*A</code></li><li><code>iterations::Int64=10</code>      - number of iterations</li><li><code>relTol::Float64=eps()</code>         - rel tolerance for stopping criterion</li></ul><p>See also <a href="solvers.html#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="solvers.html#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/CGNR.jl#L24-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.solve-Tuple{CGNR, Any}" href="#RegularizedLeastSquares.solve-Tuple{CGNR, Any}"><code>RegularizedLeastSquares.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(solver::CGNR, u; kwargs...) where vecT</code></pre><p>solves Tikhonov-regularized inverse problem using CGNR.</p><p><strong>Arguments</strong></p><ul><li>`solver::CGNR                         - the solver containing both system matrix and regularizer</li><li><code>u::vecT</code>                             - data vector</li></ul><p><strong>Keywords</strong></p><ul><li><code>startVector::vecT=similar(u,0)</code>    - initial guess for the solution</li><li><code>solverInfo=nothing</code>                - solverInfo for logging</li></ul><p>when a <code>SolverInfo</code> objects is passed, the residuals <code>solver.zl</code> are stored in <code>solverInfo.convMeas</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/CGNR.jl#L131-L145">source</a></section></article><h2 id="Kaczmarz"><a class="docs-heading-anchor" href="#Kaczmarz">Kaczmarz</a><a id="Kaczmarz-1"></a><a class="docs-heading-anchor-permalink" href="#Kaczmarz" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.Kaczmarz" href="#RegularizedLeastSquares.Kaczmarz"><code>RegularizedLeastSquares.Kaczmarz</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Kaczmarz(S, b; kwargs...)</p><p>creates a Kaczmarz object</p><p><strong>Arguments</strong></p><ul><li><code>S</code>                                             - system matrix</li><li><code>b=nothing</code>                                     - measurement</li></ul><p><strong>Keywords</strong></p><ul><li><code>reg</code>          - regularization term vector</li><li><code>normalizeReg</code>         - regularization normalization scheme</li><li><code>weights::Vector{R}=ones(Float64,size(S,1))</code> - weights for the data term</li><li><code>enforceReal::Bool=false</code>                     - constrain the solution to be real</li><li><code>enforcePositive::Bool=false</code>                 - constrain the solution to have positive real part</li><li><code>randomized::Bool=false</code>                  - randomize Kacmarz algorithm</li><li><code>subMatrixFraction::Float64=0.1</code>              - fraction of rows used in randomized Kaczmarz algorithm  </li><li><code>shuffleRows::Bool=false</code>               - randomize Kacmarz algorithm</li><li><code>seed::Int=1234</code>                      - seed for randomized algorithm</li><li>iterations::Int64=10                          - number of iterations</li></ul><p>See also <a href="solvers.html#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="solvers.html#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/Kaczmarz.jl#L28-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.solve-Tuple{Kaczmarz, Vector{Any}}" href="#RegularizedLeastSquares.solve-Tuple{Kaczmarz, Vector{Any}}"><code>RegularizedLeastSquares.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(solver::AbstractLinearSolver, b; solverInfo = nothing, kwargs...)</code></pre><p>solves an inverse problem using <code>solver</code>. When <code>solverInfo</code> is passed to the function information about the iteration process is stored.</p><p>See also <a href="API/solvers.html#RegularizedLeastSquares.SolverInfo"><code>SolverInfo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/RegularizedLeastSquares.jl#L23-L29">source</a></section><section><div><pre><code class="language-none">solve(solver::Kaczmarz, u::Vector; kwargs...)</code></pre><p>solves Tikhonov-regularized inverse problem using Kaczmarz algorithm.</p><p><strong>Arguments</strong></p><ul><li>`solver::Kaczmarz  - the solver containing both system matrix and regularizer</li><li><code>u::Vector</code>        - data vector</li></ul><p><strong>Keywords</strong></p><ul><li><code>S::matT=solver.S</code>                  - operator for the data-term of the problem</li><li><code>startVector::Vector{T}=T[]</code>        - initial guess for the solution</li><li><code>weights::Vector{T}=solver.weights</code> - weights for the data term</li><li><code>shuffleRows::Bool=false</code>           - randomize Kacmarz algorithm</li><li><code>solverInfo=nothing</code>                - solverInfo for logging</li></ul><p>when a <code>SolverInfo</code> objects is passed, the residuals are stored in <code>solverInfo.convMeas</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/Kaczmarz.jl#L164-L181">source</a></section></article><h2 id="FISTA"><a class="docs-heading-anchor" href="#FISTA">FISTA</a><a id="FISTA-1"></a><a class="docs-heading-anchor-permalink" href="#FISTA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.FISTA" href="#RegularizedLeastSquares.FISTA"><code>RegularizedLeastSquares.FISTA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FISTA(A, x; kwargs...)</code></pre><p>creates a <code>FISTA</code> object for the system matrix <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>                     - system matrix</li><li><code>x::vecT</code>               - (optional) array with the same type and size as the solution</li></ul><p><strong>Keywords</strong></p><ul><li><code>reg</code>                   - regularization term vector</li><li><code>normalizeReg</code>          - regularization normalization scheme</li><li><code>AᴴA=A&#39;*A</code>              - specialized normal operator, default is <code>A&#39;*A</code></li><li><code>ρ=0.95</code>                - step size for gradient step</li><li><code>normalize_ρ=true</code>      - normalize step size by the maximum eigenvalue of <code>AᴴA</code></li><li><code>t=1.0</code>                 - parameter for predictor-corrector step</li><li><code>relTol::=eps(real(T))</code> - tolerance for stopping criterion</li><li><code>iterations::Int64=50</code>  - maximum number of iterations</li><li><code>restart::Symbol=:none</code> - :none, :gradient options for restarting</li></ul><p>See also <a href="solvers.html#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="solvers.html#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/FISTA.jl#L24-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.solve-Tuple{FISTA, Any}" href="#RegularizedLeastSquares.solve-Tuple{FISTA, Any}"><code>RegularizedLeastSquares.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(solver::FISTA, b; kwargs...)</code></pre><p>solves an inverse problem using FISTA.</p><p><strong>Arguments</strong></p><ul><li><code>solver::FISTA</code>                     - the solver containing both system matrix and regularizer</li><li><code>b::vecT</code>                           - data vector</li></ul><p><strong>Keywords</strong></p><ul><li><code>A=solver.A</code>                        - operator for the data-term of the problem</li><li><code>startVector::vecT=similar(b,0)</code>  - initial guess for the solution</li><li><code>solverInfo=nothing</code>              - solverInfo object</li></ul><p>when a <code>SolverInfo</code> objects is passed, the residuals are stored in <code>solverInfo.convMeas</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/FISTA.jl#L113-L128">source</a></section></article><h2 id="OptISTA"><a class="docs-heading-anchor" href="#OptISTA">OptISTA</a><a id="OptISTA-1"></a><a class="docs-heading-anchor-permalink" href="#OptISTA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.OptISTA" href="#RegularizedLeastSquares.OptISTA"><code>RegularizedLeastSquares.OptISTA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptISTA(A, x; kwargs...)</code></pre><p>creates a <code>OptISTA</code> object for the system matrix <code>A</code>. OptISTA has a 2x better worst-case bound than FISTA, but actual performance varies by application. It stores 2 extra intermediate variables the size of the image compared to FISTA</p><p>Reference:</p><ul><li>Uijeong Jang, Shuvomoy Das Gupta, Ernest K. Ryu,   &quot;Computer-Assisted Design of Accelerated Composite   Optimization Methods: OptISTA,&quot; arXiv:2305.15704, 2023,   [https://arxiv.org/abs/2305.15704]</li></ul><p><strong>Arguments</strong></p><ul><li><code>A</code>                     - system matrix</li><li><code>x::vecT</code>               - array with the same type and size as the solution</li></ul><p><strong>Keywords</strong></p><ul><li><code>reg</code>                   - regularization term vector</li><li><code>normalizeReg</code>          - regularization normalization scheme</li><li><code>AᴴA=A&#39;*A</code>              - specialized normal operator, default is <code>A&#39;*A</code></li><li><code>ρ=0.95</code>                - step size for gradient step</li><li><code>normalize_ρ=true</code>      - normalize step size by the maximum eigenvalue of <code>AᴴA</code></li><li><code>θ=1.0</code>                 - parameter for predictor-corrector step</li><li><code>relTol::Float64=1.e-5</code> - tolerance for stopping criterion</li><li><code>iterations::Int64=50</code>  - maximum number of iterations</li></ul><p>See also <a href="solvers.html#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="solvers.html#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/OptISTA.jl#L29-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.solve-Tuple{OptISTA, Any}" href="#RegularizedLeastSquares.solve-Tuple{OptISTA, Any}"><code>RegularizedLeastSquares.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(solver::OptISTA, b::Vector; kwargs...)</code></pre><p>solves an inverse problem using OptISTA.</p><p><strong>Arguments</strong></p><ul><li><code>solver::OptISTA</code>                     - the solver containing both system matrix and regularizer</li><li><code>b::vecT</code>                           - data vector</li></ul><p><strong>Keywords</strong></p><ul><li><code>A=solver.A</code>                        - operator for the data-term of the problem</li><li><code>startVector::vecT=similar(b,0)</code>  - initial guess for the solution</li><li><code>solverInfo=nothing</code>              - solverInfo object</li></ul><p>when a <code>SolverInfo</code> objects is passed, the residuals are stored in <code>solverInfo.convMeas</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/OptISTA.jl#L139-L154">source</a></section></article><h2 id="POGM"><a class="docs-heading-anchor" href="#POGM">POGM</a><a id="POGM-1"></a><a class="docs-heading-anchor-permalink" href="#POGM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.POGM" href="#RegularizedLeastSquares.POGM"><code>RegularizedLeastSquares.POGM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">POGM(A, x; kwargs...)</code></pre><p>creates a <code>POGM</code> object for the system matrix <code>A</code>. POGM has a 2x better worst-case bound than FISTA, but actual performance varies by application. It stores 3 extra intermediate variables the size of the image compared to FISTA Only gradient restart scheme is implemented for now</p><p>References:</p><ul><li>A.B. Taylor, J.M. Hendrickx, F. Glineur,   &quot;Exact worst-case performance of first-order algorithms   for composite convex optimization,&quot; Arxiv:1512.07516, 2015,   SIAM J. Opt. 2017   [http://doi.org/10.1137/16m108104x]</li><li>Kim, D., &amp; Fessler, J. A. (2018).   Adaptive Restart of the Optimized Gradient Method for Convex Optimization.   Journal of Optimization Theory and Applications, 178(1), 240–263.   [https://doi.org/10.1007/s10957-018-1287-4]</li></ul><p><strong>Arguments</strong></p><ul><li><code>A</code>                     - system matrix</li><li><code>x::vecT</code>               - array with the same type and size as the solution</li></ul><p><strong>Keywords</strong></p><ul><li><code>reg</code>                   - regularization term vector</li><li><code>normalizeReg</code>          - regularization normalization scheme</li><li><code>AᴴA=A&#39;*A</code>              - specialized normal operator, default is <code>A&#39;*A</code></li><li><code>ρ=0.95</code>                - step size for gradient step</li><li><code>normalize_ρ=true</code>      - normalize step size by the maximum eigenvalue of <code>AᴴA</code></li><li><code>t=1</code>                   - parameter for predictor-corrector step</li><li><code>σ_fac=1</code>               - parameter for decreasing γ-momentum ∈ [0,1]</li><li><code>relTol::=eps(real(T))</code> - tolerance for stopping criterion</li><li><code>iterations::Int64=50</code>  - maximum number of iterations</li><li><code>restart::Symbol=:none</code> - <code>:none</code>, <code>:gradient</code> options for restarting</li><li><code>verbose::Bool=false</code>   - print residual norm in each iteration</li></ul><p>See also <a href="solvers.html#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="solvers.html#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/POGM.jl#L33-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.solve-Tuple{POGM, Any}" href="#RegularizedLeastSquares.solve-Tuple{POGM, Any}"><code>RegularizedLeastSquares.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(solver::POGM, b::Vector)</code></pre><p>solves an inverse problem using POGM.</p><p><strong>Arguments</strong></p><ul><li><code>solver::POGM</code>                     - the solver containing both system matrix and regularizer</li><li><code>b::vecT</code>                           - data vector</li></ul><p><strong>Keywords</strong></p><ul><li><code>A=solver.A</code>                        - operator for the data-term of the problem</li><li><code>startVector::vecT=similar(b,0)</code>  - initial guess for the solution</li><li><code>solverInfo=nothing</code>              - solverInfo object</li></ul><p>when a <code>SolverInfo</code> objects is passed, the residuals are stored in <code>solverInfo.convMeas</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/POGM.jl#L147-L162">source</a></section></article><h2 id="SplitBregman"><a class="docs-heading-anchor" href="#SplitBregman">SplitBregman</a><a id="SplitBregman-1"></a><a class="docs-heading-anchor-permalink" href="#SplitBregman" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.SplitBregman" href="#RegularizedLeastSquares.SplitBregman"><code>RegularizedLeastSquares.SplitBregman</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SplitBregman(A, x; kwargs...)</code></pre><p>creates a <code>SplitBregman</code> object for the system matrix <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::matT</code>                     - system matrix</li><li><code>x::vecT</code>                     - Array with the same type and size as the solution</li></ul><p><strong>Keywords</strong></p><ul><li><code>reg=nothing</code>          - regularization term vector</li><li><code>normalizeReg</code>         - regularization normalization scheme</li><li><code>precon=Identity()</code>         - preconditionner for the internal CG algorithm</li><li><code>ρ=[1.e2]</code>                  - weights for condition on regularized variables</li><li><code>iterations::Int64=10</code>      - number of outer iterations</li><li><code>iterationsInner::Int64=50</code> - maximum number of inner iterations</li><li><code>iterationsCG::Int64=10</code>    - maximum number of CG iterations</li><li><code>absTol::Float64=eps()</code>     - abs tolerance for stopping criterion</li><li><code>relTol::Float64=eps()</code>     - rel tolerance for stopping criterion</li><li><code>tolInner::Float64=1.e-5</code>   - tolerance for CG stopping criterion</li></ul><p>See also <a href="solvers.html#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="solvers.html#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/SplitBregman.jl#L43-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizedLeastSquares.solve-Tuple{SplitBregman, Any}" href="#RegularizedLeastSquares.solve-Tuple{SplitBregman, Any}"><code>RegularizedLeastSquares.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(solver::AbstractLinearSolver, b; solverInfo = nothing, kwargs...)</code></pre><p>solves an inverse problem using <code>solver</code>. When <code>solverInfo</code> is passed to the function information about the iteration process is stored.</p><p>See also <a href="API/API/solvers.html#RegularizedLeastSquares.SolverInfo"><code>SolverInfo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/RegularizedLeastSquares.jl#L23-L29">source</a></section><section><div><pre><code class="language-none">solve(solver::SplitBregman, b; kwargs...)</code></pre><p>solves an inverse problem using the Split Bregman method.</p><p><strong>Arguments</strong></p><ul><li><code>solver::SplitBregman</code>              - the solver containing both system matrix and regularizer</li><li><code>b::vecT</code>                           - data vector</li></ul><p><strong>Keywords</strong></p><ul><li><code>A::matT=solver.A</code>                - operator for the data-term of the problem</li><li><code>startVector::vecT=similar(b,0)</code>  - initial guess for the solution</li><li><code>solverInfo=nothing</code>              - solverInfo for logging</li></ul><p>when a <code>SolverInfo</code> objects is passed, the primal residuals <code>solver.rk</code> and the dual residual <code>norm(solver.sk)</code> are stored in <code>solverInfo.convMeas</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/eea53e82e66dc6506f450063b2e2510702e2dbef/src/SplitBregman.jl#L201-L217">source</a></section></article><h2 id="Direct"><a class="docs-heading-anchor" href="#Direct">Direct</a><a id="Direct-1"></a><a class="docs-heading-anchor-permalink" href="#Direct" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../regularization.html">« Regularization</a><a class="docs-footer-nextpage" href="regularization.html">Regularization Terms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 2 January 2024 18:38">Tuesday 2 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
