<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · RegularizedLeastSquares.jl</title><meta name="title" content="Solvers · RegularizedLeastSquares.jl"/><meta property="og:title" content="Solvers · RegularizedLeastSquares.jl"/><meta property="twitter:title" content="Solvers · RegularizedLeastSquares.jl"/><meta name="description" content="Documentation for RegularizedLeastSquares.jl."/><meta property="og:description" content="Documentation for RegularizedLeastSquares.jl."/><meta property="twitter:description" content="Documentation for RegularizedLeastSquares.jl."/><meta property="og:url" content="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/API/solvers/"/><meta property="twitter:url" content="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/API/solvers/"/><link rel="canonical" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/API/solvers/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RegularizedLeastSquares.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../gettingStarted/">Getting Started</a></li><li><a class="tocitem" href="../../solvers/">Solvers</a></li><li><a class="tocitem" href="../../regularization/">Regularization</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>Solvers</a><ul class="internal"><li><a class="tocitem" href="#solve"><span>solve</span></a></li><li><a class="tocitem" href="#ADMM"><span>ADMM</span></a></li><li><a class="tocitem" href="#CGNR"><span>CGNR</span></a></li><li><a class="tocitem" href="#Kaczmarz"><span>Kaczmarz</span></a></li><li><a class="tocitem" href="#FISTA"><span>FISTA</span></a></li><li><a class="tocitem" href="#OptISTA"><span>OptISTA</span></a></li><li><a class="tocitem" href="#POGM"><span>POGM</span></a></li><li><a class="tocitem" href="#SplitBregman"><span>SplitBregman</span></a></li><li><a class="tocitem" href="#Miscellaneous-Functions"><span>Miscellaneous Functions</span></a></li></ul></li><li><a class="tocitem" href="../regularization/">Regularization Terms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/master/docs/src/API/solvers.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-for-Solvers"><a class="docs-heading-anchor" href="#API-for-Solvers">API for Solvers</a><a id="API-for-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#API-for-Solvers" title="Permalink"></a></h1><p>This page contains documentation of the public API of the RegularizedLeastSquares. In the Julia REPL one can access this documentation by entering the help mode with <code>?</code></p><h2 id="solve"><a class="docs-heading-anchor" href="#solve">solve</a><a id="solve-1"></a><a class="docs-heading-anchor-permalink" href="#solve" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}" href="#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>RegularizedLeastSquares.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(solver::AbstractLinearSolver, b; x0 = 0, f_trace = (_, _) -&gt; nothing)</code></pre><p>Solves an inverse problem for the data vector <code>b</code> using <code>solver</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>solver::AbstractLinearSolver</code>    - linear solver (e.g., <code>ADMM</code> or <code>FISTA</code>), containing forward/normal operator and regularizer</li><li><code>b::AbstractVector</code>               - data vector if <code>A</code> was supplied to the solver, back-projection of the data otherwise</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>x0::AbstractVector</code>              - initial guess for the solution; default is zero</li><li><code>f_trace::Function</code>               - function that takes the two arguments <code>f_trace(solver, iteration)</code> and, e.g., stores, prints, or plots the intermediate solutions or convergence parameters.</li></ul><p><strong>Examples</strong></p><p>The optimization problem</p><p class="math-container">\[	argmin_x ||Ax - b||_2^2 + λ ||x||_1\]</p><p>can be solved with the following lines of code:</p><pre><code class="language-julia-repl hljs">julia&gt; using RegularizedLeastSquares

julia&gt; A = [0.831658  0.96717
            0.383056  0.39043
            0.820692  0.08118];

julia&gt; x = [0.5932234523399985; 0.2697534345340015];

julia&gt; b = A * x;

julia&gt; S = ADMM(A);

julia&gt; x_approx = solve(S, b)
2-element Vector{Float64}:
 0.5932234523399984
 0.26975343453400163</code></pre><p>Here, we use <a href="../regularization/#RegularizedLeastSquares.L1Regularization"><code>L1Regularization</code></a>, which is default for <a href="#RegularizedLeastSquares.ADMM"><code>ADMM</code></a>. All regularization options can be found in <a href="../regularization/#API-for-Regularizers">API for Regularizers</a>.</p><p>The following example solves the same problem, but stores the solution <code>x</code> of each interation in <code>tr</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; tr = Dict[]
Dict[]

julia&gt; store_trace!(tr, solver, iteration) = push!(tr, Dict(&quot;iteration&quot; =&gt; iteration, &quot;x&quot; =&gt; solver.x, &quot;beta&quot; =&gt; solver.β))
store_trace! (generic function with 1 method)

julia&gt; x_approx = solve(S, b; f_trace=(solver, iteration) -&gt; store_trace!(tr, solver, iteration))
2-element Vector{Float64}:
 0.5932234523399984
 0.26975343453400163

julia&gt; tr[3]
Dict{String, Any} with 3 entries:
  &quot;iteration&quot; =&gt; 2
  &quot;x&quot;         =&gt; [0.593223, 0.269753]
  &quot;beta&quot;      =&gt; [1.23152, 0.927611]</code></pre><p>The last example show demonstrates how to plot the solution at every 10th iteration:</p><pre><code class="language-julia hljs">julia&gt; using Plots

julia&gt; function plot_trace(solver, iteration)
         if iteration % 10 == 0
           display(scatter(solver.x))
         end
       end
plot_trace (generic function with 1 method)

julia&gt; x_approx = solve(S, b; f_trace = plot_trace);</code></pre><p>The keyword <code>f_trace</code> allows you to pass any function that takes the arguments <code>solver</code> and <code>iteration</code> and prints, stores, or plots intermediate result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/RegularizedLeastSquares.jl#L22-L96">source</a></section></article><h2 id="ADMM"><a class="docs-heading-anchor" href="#ADMM">ADMM</a><a id="ADMM-1"></a><a class="docs-heading-anchor-permalink" href="#ADMM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.ADMM" href="#RegularizedLeastSquares.ADMM"><code>RegularizedLeastSquares.ADMM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ADMM(A; AHA = A&#39;*A, precon = Identity(), reg = L1Regularization(zero(eltype(AHA))), normalizeReg = NoNormalization(), rho = 1e-1, vary_rho = :none, iterations = 50, iterationsInner = 10, absTol = eps(real(eltype(AHA))), relTol = eps(real(eltype(AHA))), tolInner = 1e-5, verbose = false)
ADMM( ; AHA = ,     precon = Identity(), reg = L1Regularization(zero(eltype(AHA))), normalizeReg = NoNormalization(), rho = 1e-1, vary_rho = :none, iterations = 50, iterationsInner = 10, absTol = eps(real(eltype(AHA))), relTol = eps(real(eltype(AHA))), tolInner = 1e-5, verbose = false)</code></pre><p>creates an <code>ADMM</code> object for the forward operator <code>A</code> or normal operator <code>AHA</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p>OR</p><ul><li><code>AHA</code>                                               - normal operator (as a keyword argument)</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>precon</code>                                            - preconditionner for the internal CG algorithm</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term; can also be a vector of regularization terms</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>rho::Real</code>                                         - penalty of the augmented Lagrangian</li><li><code>vary_rho::Symbol</code>                                  - vary rho to balance primal and dual feasibility; options <code>:none</code>, <code>:balance</code>, <code>:PnP</code></li><li><code>iterations::Int</code>                                   - maximum number of (outer) ADMM iterations</li><li><code>iterationsInner::Int</code>                              - max number of (inner) CG iterations</li><li><code>absTol::Real</code>                                      - abs tolerance for stopping criterion</li><li><code>relTol::Real</code>                                      - tolerance for stopping criterion</li><li><code>tolInner::Real</code>                                    - rel tolerance for CG stopping criterion</li><li><code>verbose::Bool</code>                                     - print residual in each iteration</li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/ADMM.jl#L42-L68">source</a></section></article><h2 id="CGNR"><a class="docs-heading-anchor" href="#CGNR">CGNR</a><a id="CGNR-1"></a><a class="docs-heading-anchor-permalink" href="#CGNR" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.CGNR" href="#RegularizedLeastSquares.CGNR"><code>RegularizedLeastSquares.CGNR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CGNR(A; AHA = A&#39; * A, reg = L2Regularization(zero(real(eltype(AHA)))), normalizeReg = NoNormalization(), weights = similar(AHA, 0), iterations = 10, relTol = eps(real(eltype(AHA))))
CGNR( ; AHA = ,       reg = L2Regularization(zero(real(eltype(AHA)))), normalizeReg = NoNormalization(), weights = similar(AHA, 0), iterations = 10, relTol = eps(real(eltype(AHA))))</code></pre><p>creates an <code>CGNR</code> object for the forward operator <code>A</code> or normal operator <code>AHA</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p>OR</p><ul><li><code>AHA</code>                                               - normal operator (as a keyword argument)</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term; can also be a vector of regularization terms</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>weights::AbstactVector</code>                            - weights for the data term; must be of same length and type as the data term</li><li><code>iterations::Int</code>                                   - maximum number of iterations</li><li><code>relTol::Real</code>                                      - tolerance for stopping criterion</li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/CGNR.jl#L22-L42">source</a></section></article><h2 id="Kaczmarz"><a class="docs-heading-anchor" href="#Kaczmarz">Kaczmarz</a><a id="Kaczmarz-1"></a><a class="docs-heading-anchor-permalink" href="#Kaczmarz" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.Kaczmarz" href="#RegularizedLeastSquares.Kaczmarz"><code>RegularizedLeastSquares.Kaczmarz</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Kaczmarz(A; reg = L2Regularization(0), normalizeReg = NoNormalization(), weights=nothing, randomized=false, subMatrixFraction=0.15, shuffleRows=false, seed=1234, iterations=10, regMatrix=nothing)</code></pre><p>Creates a Kaczmarz object for the forward operator <code>A</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>weights::AbstractVector</code>                             - weights for the data term</li><li><code>randomized::Bool</code>                                    - randomize Kacmarz algorithm</li><li><code>subMatrixFraction::Real</code>                             - fraction of rows used in randomized Kaczmarz algorithm</li><li><code>shuffleRows::Bool</code>                                   - randomize Kacmarz algorithm</li><li><code>seed::Int</code>                                           - seed for randomized algorithm</li><li><code>iterations::Int</code>                                     - number of iterations</li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/Kaczmarz.jl#L28-L47">source</a></section></article><h2 id="FISTA"><a class="docs-heading-anchor" href="#FISTA">FISTA</a><a id="FISTA-1"></a><a class="docs-heading-anchor-permalink" href="#FISTA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.FISTA" href="#RegularizedLeastSquares.FISTA"><code>RegularizedLeastSquares.FISTA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FISTA(A; AHA=A&#39;*A, reg=L1Regularization(zero(eltype(AHA))), normalizeReg=NoNormalization(), rho=0.95, normalize_rho=true, theta=1, relTol=eps(real(eltype(AHA))), iterations=50, restart = :none, verbose = false)
FISTA( ; AHA=,     reg=L1Regularization(zero(eltype(AHA))), normalizeReg=NoNormalization(), rho=0.95, normalize_rho=true, theta=1, relTol=eps(real(eltype(AHA))), iterations=50, restart = :none, verbose = false)</code></pre><p>creates a <code>FISTA</code> object for the forward operator <code>A</code> or normal operator <code>AHA</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p>OR</p><ul><li><code>AHA</code>                                               - normal operator (as a keyword argument)</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>precon</code>                                            - preconditionner for the internal CG algorithm</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term; can also be a vector of regularization terms</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>rho::Real</code>                                         - step size for gradient step</li><li><code>normalize_rho::Bool</code>                               - normalize step size by the largest eigenvalue of <code>AHA</code></li><li><code>theta::Real</code>                                       - parameter for predictor-corrector step</li><li><code>relTol::Real</code>                                      - tolerance for stopping criterion</li><li><code>iterations::Int</code>                                   - maximum number of iterations</li><li><code>restart::Symbol</code>                                   - <code>:none</code>, <code>:gradient</code> options for restarting</li><li><code>verbose::Bool</code>                                     - print residual in each iteration</li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/FISTA.jl#L24-L49">source</a></section></article><h2 id="OptISTA"><a class="docs-heading-anchor" href="#OptISTA">OptISTA</a><a id="OptISTA-1"></a><a class="docs-heading-anchor-permalink" href="#OptISTA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.OptISTA" href="#RegularizedLeastSquares.OptISTA"><code>RegularizedLeastSquares.OptISTA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OptISTA(A; AHA=A&#39;*A, reg=L1Regularization(zero(eltype(AHA))), normalizeReg=NoNormalization(), rho=0.95, normalize_rho=true, theta=1, relTol=eps(real(eltype(AHA))), iterations=50, verbose = false)
OptISTA( ; AHA=,     reg=L1Regularization(zero(eltype(AHA))), normalizeReg=NoNormalization(), rho=0.95, normalize_rho=true, theta=1, relTol=eps(real(eltype(AHA))), iterations=50, verbose = false)</code></pre><p>creates a <code>OptISTA</code> object for the forward operator <code>A</code> or normal operator <code>AHA</code>. OptISTA has a 2x better worst-case bound than FISTA, but actual performance varies by application. It stores 2 extra intermediate variables the size of the image compared to FISTA.</p><p>Reference:</p><ul><li>Uijeong Jang, Shuvomoy Das Gupta, Ernest K. Ryu, &quot;Computer-Assisted Design of Accelerated Composite Optimization Methods: OptISTA,&quot; arXiv:2305.15704, 2023, [https://arxiv.org/abs/2305.15704]</li></ul><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p>OR</p><ul><li><code>AHA</code>                                               - normal operator (as a keyword argument)</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>rho::Real</code>                                         - step size for gradient step</li><li><code>normalize_rho::Bool</code>                               - normalize step size by the largest eigenvalue of <code>AHA</code></li><li><code>theta::Real</code>                                       - parameter for predictor-corrector step</li><li><code>relTol::Real</code>                                      - tolerance for stopping criterion</li><li><code>iterations::Int</code>                                   - maximum number of iterations</li><li><code>verbose::Bool</code>                                     - print residual in each iteration</li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/OptISTA.jl#L29-L55">source</a></section></article><h2 id="POGM"><a class="docs-heading-anchor" href="#POGM">POGM</a><a id="POGM-1"></a><a class="docs-heading-anchor-permalink" href="#POGM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.POGM" href="#RegularizedLeastSquares.POGM"><code>RegularizedLeastSquares.POGM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">POGM(A; AHA = A&#39;*A, reg = L1Regularization(zero(eltype(AHA))), normalizeReg = NoNormalization(), rho = 0.95, normalize_rho = true, theta = 1, sigma_fac = 1, relTol = eps(real(eltype(AHA))), iterations = 50, restart = :none, verbose = false)
POGM( ; AHA = ,     reg = L1Regularization(zero(eltype(AHA))), normalizeReg = NoNormalization(), rho = 0.95, normalize_rho = true, theta = 1, sigma_fac = 1, relTol = eps(real(eltype(AHA))), iterations = 50, restart = :none, verbose = false)</code></pre><p>Creates a <code>POGM</code> object for the forward operator <code>A</code> or normal operator <code>AHA</code>. POGM has a 2x better worst-case bound than FISTA, but actual performance varies by application. It stores 3 extra intermediate variables the size of the image compared to FISTA. Only gradient restart scheme is implemented for now.</p><p><strong>References:</strong></p><ul><li><p>A.B. Taylor, J.M. Hendrickx, F. Glineur,   &quot;Exact worst-case performance of first-order algorithms   for composite convex optimization,&quot; Arxiv:1512.07516, 2015,   SIAM J. Opt. 2017   [http://doi.org/10.1137/16m108104x]</p></li><li><p>Kim, D., &amp; Fessler, J. A. (2018).   Adaptive Restart of the Optimized Gradient Method for Convex Optimization.   Journal of Optimization Theory and Applications, 178(1), 240–263.   [https://doi.org/10.1007/s10957-018-1287-4]</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p>OR</p><ul><li><code>AHA</code>                                               - normal operator (as a keyword argument)</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>rho::Real</code>                                         - step size for gradient step</li><li><code>normalize_rho::Bool</code>                               - normalize step size by the largest eigenvalue of <code>AHA</code></li><li><code>theta::Real</code>                                       - parameter for predictor-corrector step</li><li><code>sigma_fac::Real</code>                                   - parameter for decreasing γ-momentum ∈ [0,1]</li><li><code>relTol::Real</code>                                      - tolerance for stopping criterion</li><li><code>iterations::Int</code>                                   - maximum number of iterations</li><li><code>restart::Symbol</code>                                   - <code>:none</code>, <code>:gradient</code> options for restarting</li><li><code>verbose::Bool</code>                                     - print residual in each iteration</li></ul></li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/POGM.jl#L33-L69">source</a></section></article><h2 id="SplitBregman"><a class="docs-heading-anchor" href="#SplitBregman">SplitBregman</a><a id="SplitBregman-1"></a><a class="docs-heading-anchor-permalink" href="#SplitBregman" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.SplitBregman" href="#RegularizedLeastSquares.SplitBregman"><code>RegularizedLeastSquares.SplitBregman</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplitBregman(A; AHA = A&#39;*A, reg = L1Regularization(zero(eltype(AHA))), normalizeReg = NoNormalization(), precon = Identity(), rho = 1.e2absTol = eps(), relTol = eps(), tolInner = 1.e-6, iterations::Int = 10, iterationsInner::Int = 50, iterationsCG::Int = 10)</code></pre><p>Creates a <code>SplitBregman</code> object for the forward operator <code>A</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>A</code>                                                 - forward operator</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>AHA</code>                                               - normal operator is optional if <code>A</code> is supplied</li><li><code>reg::AbstractParameterizedRegularization</code>          - regularization term</li><li><code>normalizeReg::AbstractRegularizationNormalization</code> - regularization normalization scheme; options are <code>NoNormalization()</code>, <code>MeasurementBasedNormalization()</code>, <code>SystemMatrixBasedNormalization()</code></li><li><code>precon</code>                                            - preconditionner for the internal CG algorithm</li><li><code>rho::Real</code>                                         - weights for condition on regularized variables; can also be a vector for multiple regularization terms</li><li><code>absTol::Float64</code>                                   - absolute tolerance for stopping criterion</li><li><code>relTol::Float64</code>                                   - relative tolerance for stopping criterion</li><li><code>tolInner::Float64</code>                                 - tolerance for CG stopping criterion</li><li><code>iterations::Int</code>                                   - maximum number of iterations</li><li><code>iterationsInner::Int</code>                              - maximum number of inner iterations</li><li><code>iterationsCG::Int</code>                                 - maximum number of CG iterations</li></ul><p>See also <a href="#RegularizedLeastSquares.createLinearSolver"><code>createLinearSolver</code></a>, <a href="#RegularizedLeastSquares.solve-Tuple{AbstractLinearSolver, Any}"><code>solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/SplitBregman.jl#L42-L64">source</a></section></article><h2 id="Miscellaneous-Functions"><a class="docs-heading-anchor" href="#Miscellaneous-Functions">Miscellaneous Functions</a><a id="Miscellaneous-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.linearSolverList" href="#RegularizedLeastSquares.linearSolverList"><code>RegularizedLeastSquares.linearSolverList</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a list of all available linear solvers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/RegularizedLeastSquares.jl#L145-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.createLinearSolver" href="#RegularizedLeastSquares.createLinearSolver"><code>RegularizedLeastSquares.createLinearSolver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">createLinearSolver(solver::AbstractLinearSolver, A; kargs...)</code></pre><p>This method creates a solver. The supported solvers are methods typically used for solving regularized linear systems. All solvers return an approximate solution to Ax = b.</p><p>TODO: give a hint what solvers are available</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/RegularizedLeastSquares.jl#L201-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.SolverInfo" href="#RegularizedLeastSquares.SolverInfo"><code>RegularizedLeastSquares.SolverInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Solver Info type is used to obtain aditional information of linear solvers and their iteration process.</p><p><strong>Fields</strong></p><ul><li><code>convMeas::Vector{Float64}</code> - Vector with convergence parameters</li><li><code>nrmse::Vector{Float64}</code>    - NRMSD of the current iterate w.r.t some reference (if provided)</li><li><code>x_ref::Vector{T}</code>          - Reference for computing NRMSD of iterates</li><li><code>x_iter::Vector{Vector{T}}</code> - Vector for storing iterates</li><li><code>store_solutions::Bool</code>     - specification whether iterates are to be stored</li></ul><p>the content of <code>convMeas</code> is specific to each solver. It can be found in the documentation of the corresping <code>solve</code>-method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/Utils.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.applicableSolverList" href="#RegularizedLeastSquares.applicableSolverList"><code>RegularizedLeastSquares.applicableSolverList</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">applicable(args...)</code></pre><p>list all <code>solvers</code> that are applicable to the given arguments. Arguments are the same as for <code>isapplicable</code> without the <code>solver</code> type.</p><p>See also <a href="#RegularizedLeastSquares.isapplicable"><code>isapplicable</code></a>, <a href="#RegularizedLeastSquares.linearSolverList"><code>linearSolverList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/RegularizedLeastSquares.jl#L192-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegularizedLeastSquares.isapplicable" href="#RegularizedLeastSquares.isapplicable"><code>RegularizedLeastSquares.isapplicable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isapplicable(solverType::Type{&lt;:AbstractLinearSolver}, A, x, reg)</code></pre><p>return <code>true</code> if a <code>solver</code> of type <code>solverType</code> is applicable to system matrix <code>A</code>, data <code>x</code> and regularization terms <code>reg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/3a863f3e008f4976886480c57ec2d38c551d337c/src/RegularizedLeastSquares.jl#L185-L189">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../regularization/">« Regularization</a><a class="docs-footer-nextpage" href="../regularization/">Regularization Terms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 5 December 2023 02:30">Tuesday 5 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
