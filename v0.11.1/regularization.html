<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Regularization · RegularizedLeastSquares.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RegularizedLeastSquares.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="gettingStarted.html">Getting Started</a></li><li><a class="tocitem" href="solvers.html">Solvers</a></li><li class="is-active"><a class="tocitem" href="regularization.html">Regularization</a><ul class="internal"><li><a class="tocitem" href="#Parameterized-Regularization-Terms"><span>Parameterized Regularization Terms</span></a></li><li><a class="tocitem" href="#Projection-Regularization-Terms"><span>Projection Regularization Terms</span></a></li><li><a class="tocitem" href="#Nested-Regularization-Terms"><span>Nested Regularization Terms</span></a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="API/solvers.html">Solvers</a></li><li><a class="tocitem" href="API/regularization.html">Regularization Terms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="regularization.html">Regularization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="regularization.html">Regularization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImageRecon/RegularizedLeastSquares.jl/blob/master/docs/src/regularization.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Regularization"><a class="docs-heading-anchor" href="#Regularization">Regularization</a><a id="Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Regularization" title="Permalink"></a></h1><p>When formulating inverse problems, a Regularizer is formulated as an additional term in a cost function, which has to be minimized. Popular optimizers often deal with a regularizers <span>$g$</span>, by computing the proximal map</p><p class="math-container">\[\begin{equation}
  prox_g (\mathbf{x}) = \underset{\mathbf{u}}{argmin} \frac{1}{2}\vert\vert \mathbf{u}-\mathbf{x} \vert {\vert}^2 + g(\mathbf{x}).
\end{equation}\]</p><p>In order to implement those kinds of algorithms,RegularizedLeastSquares defines the following type hierarchy:</p><pre><code class="language-julia">abstract type AbstractRegularization
prox!(reg::AbstractRegularization, x)
norm(reg::AbstractRegularization, x)</code></pre><p>Here <code>prox!(reg, x)</code> is an in-place function which computes the proximal map on the input-vector <code>x</code>. The function <code>norm</code> computes the value of the corresponding term in the inverse problem. RegularizedLeastSquares.jl provides <code>AbstractParameterizedRegularization</code> and <code>AbstractProjectionRegularization</code> as core regularization types.</p><h2 id="Parameterized-Regularization-Terms"><a class="docs-heading-anchor" href="#Parameterized-Regularization-Terms">Parameterized Regularization Terms</a><a id="Parameterized-Regularization-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Parameterized-Regularization-Terms" title="Permalink"></a></h2><p>This group of regularization terms features a regularization parameter <code>λ</code> that is used during the <code>prox!</code> and <code>norm</code>computations. Examples of this regulariztion group are <code>L1</code>, <code>L2</code> or <code>LLR</code> (locally low rank) regularization terms.</p><p>These terms are constructed by supplying a <code>λ</code> and optionally term specific keyword arguments:</p><pre><code class="language-julia-repl">julia&gt; l2 = L2Regularization(0.3)
L2Regularization{Float64}(0.3)</code></pre><p>Parameterized regularization terms implement:</p><pre><code class="language-julia">prox!(reg::AbstractParameterizedRegularization, x, λ)
norm(reg::AbstractParameterizedRegularization, x, λ)</code></pre><p>where <code>λ</code> by default is filled with the value used during construction.</p><p>Invoking <code>λ</code> on a parameterized term retrieves its regularization parameter. This can be used in a solver to scale and overwrite the parameter as follows:</p><pre><code class="language-julia-repl">julia&gt; prox!(l2, [1.0])
1-element Vector{Float64}:
 0.625

julia&gt; param = λ(l2)
0.3

julia&gt; prox!(l2, [1.0], param*0.2)
1-element Vector{Float64}:
 0.8928571428571428
</code></pre><h2 id="Projection-Regularization-Terms"><a class="docs-heading-anchor" href="#Projection-Regularization-Terms">Projection Regularization Terms</a><a id="Projection-Regularization-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Projection-Regularization-Terms" title="Permalink"></a></h2><p>This group of regularization terms implement projections, such as a positivity constraint or a projection with a given convex projection function.</p><pre><code class="language-julia-repl">julia&gt; positive = PositiveRegularization()
PositiveRegularization()

julia&gt; prox!(positive, [2.0, -0.2])
2-element Vector{Float64}:
 2.0
 0.0</code></pre><h2 id="Nested-Regularization-Terms"><a class="docs-heading-anchor" href="#Nested-Regularization-Terms">Nested Regularization Terms</a><a id="Nested-Regularization-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Nested-Regularization-Terms" title="Permalink"></a></h2><p>Nested regularization terms are terms that act as decorators to the core regularization terms. These terms can be nested around other terms and add functionality to a regularization term, such as scaling <code>λ</code> based on the provided system matrix or applying a transform, such as the Wavelet, to <code>x</code>:</p><pre><code class="language-julia-repl">julia&gt; core = L1Regularization(0.8)
L1Regularization{Float64}(0.8)

julia&gt; wop = WaveletOp(Float32, shape = (32,32));

julia&gt; reg = TransformedRegularization(core, wop);

julia&gt; prox!(reg, randn(32*32)); # Apply soft-thresholding in Wavelet domain</code></pre><p>The type of regularization term a nested term can be wrapped around depends on the concrete type of the nested term. However generally, they can be nested arbitrarly deep, adding new functionality with each layer. Each nested regularization term can return its <code>inner</code> regularization. Furthermore, all regularization terms implement the iteration interface to iterate over the nesting. The innermost regularization term of a nested term must be a core regularization term and it can be returned by the <code>sink</code> function:</p><pre><code class="language-julia-repl">julia&gt; inner(reg) == core
true

julia&gt; sink(reg) == core
true

julia&gt; foreach(r -&gt; println(nameof(typeof(r))), reg)
TransformedRegularization
L1Regularization</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="solvers.html">« Solvers</a><a class="docs-footer-nextpage" href="API/solvers.html">Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 14 November 2023 11:24">Tuesday 14 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
